
/*******************************************************************************************************
 * MARCUS - 2018
 * Comunicacao I2c implementada.
 *
 * PERALTA, ENDRYL, WELLINGTON
 * Vers�o 4 do gerenciamento FLEX, recalibra��o da l�gica de dist�rbios de carga acoplados ao motor
 *
 * PERALTA
 * Vers�o com implementa��o do controle lambda no PIC gerenciamento , trocando o lugar de envio do tempo de inje��o
 * (envia por primeiro)
 * Troca de lugar o envio do estado de controle de rota��o de marcha lenta.
 * Sem sincronismo na comunica��o entre os PICs Gerenciamento e Sincronismo
 *
 *
 * PERALTA , ENDRYL, WELLINGTON.
 * Vers�o com prot�tipo do controle lambda no uc de gerenciamento (funcionamento intermitente).
 *  Corre��o do tempo de inje��o do controle lambda feita antes de todas as corre��es
 *  �ltima vers�o sem altera��es na comunica��o
 *
 * PERALTA
 *O gerenciamento agora recebe os valores de angulo da borboleta do admiss�o(thales) , por enquanto em oito bits para teste
 * controle de rpm reajustado para o novo controle de borboleta
 * Created on 12 de abril de 2017, 18:08
 * SW GERENCIAMENTO VERS�O 1.0

 * Modifica��o: In�cio declara��es e SPI
 * 05/05/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 27 de Junho de 2016, 23:40
 * SW GERENCIAMENTO VERS�O 1.0
 * Autor: Gustavo Hiroki
 * Modifica��o: Implementa��o de Timer�s 0/1/2/3/4/5/6
 * 27/06/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 4 de Julho de 2016, 16:47
 * SW GERENCIAMENTO VERS�O 1.0
 * Autor: Gustavo Hiroki
 * Modifica��o: Implementa��o e Teste de Interrup��o Externa
 * 04/07/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 5 de Julho de 2016, 16:33
 * SW GERENCIAMENTO VERS�O 1.0
 * Autor: Gustavo Hiroki
 * Modifica��o: Configura��o do HW e Finaliza��o
 * 05/07/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 9 de Julho de 2016, 13:28
 * SW GERENCIAMENTO VERS�O 1.0
 * Autor: Gustavo Hiroki
 * Modifica��o: Efetuado testes em HW(Demerson)
 * 09/07/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 17 de Setembro de 2016, 13:28
 * SW GERENCIAMENTO VERS�O 1.0
 * Autor: Gustavo Hiroki
 * Modifica��o: Modifica��o placa MARK1
 * 17/09/2016
 ******************************************************************************************************/

/**************************************** INCLUDE LIBRARY ********************************************/

#include <xc.h>
#include <math.h>
#include <pic18f46k22.h>
#include "Config_XC8.h"
#include "SPI_XC8.h"
#include "TIMERS_XC8.h"
#include "EXT_INT.h"
#include "ADC_K22.h"
#include "ConfigI2c.h"

#define     GOL     1
#define     POLO    0
#define     CarCfg  POLO


/******************************************* DEFINES ************************************************/
#define     nSINAL_ENT       LATBbits.LATB0     //Rota��o Input
#define     nROT_CCP2        LATBbits.LATB3
#define     nSINAL_SS_SINC   LATCbits.LATC6     //RC6 Dig Output
#define     nSINAL_SS_ADM    LATEbits.LATE1     //RE1 Dig Output
#define     nSINAL_SS_COM    LATBbits.LATB2     //RB2 Dig Output
#define     nSINAL_SS_33810  LATCbits.LATC1
#define     nSINAL_SS_33972  LATCbits.LATC2     //ChipSelect KNOCK Sensor
#define     nSINAL_FALHA     LATBbits.LATB7
#define     nL15             LATBbits.LATB1
#define     nBOMBA_CB        LATDbits.LATD1
#define     PORTB5_nL15      PORTBbits.RB1
#define     nLED_TEST        LATCbits.LATC0     //RC0 Dig Output
#define     nCOMBUSTIVEL_PIN LATDbits.LATD3
#define     nEMBREAGEM_PIN   LATCbits.LATC7
#define     nBUTTON_AC       PORTDbits.RD6
#define     nRELE_BOMB_INJ   LATDbits.LATD7
#define     nHOLD_KNOCK      LATBbits.LATB6
#define     nFREIO_1         LATDbits.LATD2
#define     nFREIO_2         LATDbits.LATD5
#define     nDO_KNOCK        LATEbits.LATE2


#define     nPin_TESTE       LATBbits.LATB6
/*********************************** Calibra��es - Polo *********************************************/
#define     nPEDAL_MAXPOLO      185.6      // Pedal pressionado
#define     nPEDAL_MINPOLO      46.0       // Pedal solto

#define     Treshold_rpm       750

#define     nPEDAL_MAXGOL       191.0 // valor polo sorocaba com o pedal pressionado
#define     nPEDAL_MINGOL       37.0 // valor polo  sorocaba com o pedal solto ( medidos no dia que o bruninho e o demerson estavam na FATEC-SO)

#define     MAX_TORQUE_1          35 // era 30 limita��o da porcentagem de torque requerida

#define     MAX_TORQUE_2         50

#define     MAX_TORQUE_TOTAL     100

#define     TPS_MAX_1            25

#define     TPS_MAX_2            40

#define     TPS_MAX_3            55

#define     rotacao_max          4500

#define     rotacao_min          2500


#define     nTPS_MAXPOLO        241.0      // Borboleta Aberta
#define     nTPS_MIN2POLO       24.0       // Borboleta Completamente fechada

#define     nTPS_MAXGOL         239   // valor da borboleta do polo de sorocaba
#define     nTPS_MIN2GOL       24.5  // valor da borboleta do polo de sorocaba

#define     nTPS_MIN            39       // Borboleta Fechada (Relaxada) VALOR DA BORBOLETA DO POLO (limp home)

#define     nTPS_1000           34.0       // Borboleta na posicao de regime
#define     nTPS_6000           65.0       // Borboleta na posicao para rotacao = 6000 rpm

#define     nMAX_TIME_INJPOLO   10000.0
#define     nMIN_TIME_INJPOLO   2800.0//3000//2700.0

#define     nMAX_TIME_INJGOL    16000.0    //us
#define     nMIN_TIME_INJGOL      1500//2700.0     //us

#define     Bob_TimingPOLO      5800.0
#define     Vazao_InjPOLO       339.11717  /*POLO  1/(176.93/60) */

#define     Vazao_InjGOL         300.3// valor calculado para o POLO de Sorocaba//400.0      /*GOL vaz�o de 2,5 g/seg*/
#define     Bob_TimingGOL       4000.0

// EQUIPE FATEC SOROCABA SITUA��O DE MARCHA LENTA
#define   n1000_RPM              50
#define   n900_RPM               100
#define   n800_RPM               150
#define   Desabilitado            0

//#define     Const_Gases         1379.379        //1727.707
#define     Const_Gases         1397   // calculado pela FATEC SOROCABA

#define     MIN_REFVB           30.0 // estava em 34 por isso arota��o n�o ca�a
/*****************************************************************************************************/
#define     nPin_HIGH            1
#define     nPin_LOW             0
#define     nYes                 1
#define     nNo                  0
#define     nON                  1
#define     nOFF                 0
#define     nDigital_Pin         0
#define     nAnalog_Pin          1

/********************************** Variaveis globais *************************************************/

unsigned int valorCalibrado = 0;


short int a, b, c, d, e; /* Variaveis de status do programa */
unsigned char dente; /* Incrementado a cada dente */
int rotacao_mlenta = 1100;
int rotacao; /* Rotacao do motor dividida por 100. 0 a 60 - 0 RPM a 6000 RPM */
long int t_periodo, t_periodo_ref; /* Armazena os tempos de patamar em alto */
unsigned char address; /* Guarda o deslocamento para a leitura na memoria de programa */
unsigned char address_2;
int periodo; // Periodo do dente (em contagem)
int n_extra;
unsigned int angle = 0;
unsigned char p_rail = 0; // variavel para contador de tempo da bomba ligada ap�s a linha 15
int ig_pos; // Variavel de controle da ignicao.
// 0-sem ignicao
unsigned char angulo[2];
// 1-sinal de ignicao ativo(2ms)
// 23-inicio da ignicao do "meio" (cil. 2 e 3)
// 14-inicio da ignicao do "fim" (cil. 1 e 4)

/*_____short calculo_ok;____ */
short falha_ok;
short volta_i2c;

unsigned char limpa;

/* VARI�VEIS REFERENTES AO CONTROLE LAMBDA (EQUIPE FATEC SOROCABA)*/
float KPlambda = 0.07; // Kp fixo, varia��o pequena
float Max_Control = 300; // Limitacao superior do incremento de injecao
float Min_Control = -300; // Limitacao inferior do incremento de injecao
float KIlambda = 0.07; // 0.07; // 0.09 Ganho Integral
float Ts = 0; // Periodo do controle
float erro_lambda = 0; // Erro
// Sinal de controle = incremento do fator multiplicativo do tempo de injecao
float U_P = 0, U_I = 0, UI_ant = 0; // Incremento da acao proporcional e integral do controlador
float Rlambda; // 1 - Mistura Rica; 0 - Mistura Pobre
//unsigned char flSaturacao = 0; // Se igual a 1 indica que houve saturacao do sinal de controle
//static unsigned char flAceleracao = 0; // Se igual a 1 indica que houve uma aceleracao
float erro_lambda_ant = 0; // Erro anterior
float control_ant = 0; // Sinal de controle anterior


unsigned char refVBCal = 34, contCal = 0;


/*_________________________________ Variaveis para injecao e ignicao ____________________________________*/
int ig_dente_14; /* Armazena o dente de referencia para a ignicao 14 */
int ig_tmr_disparo; /* Armazena o tempo de disparo do timer0 a partir
                                                   do dente de referencia (igual para as duas ignicoes) */
int ij_dente_14; /* Armazena o dente de referencia para a injecoes 1 e 4 */
int ij_tmr_disparo; /* Armazena o tempo de disparo do timer3 a partir
                                                   do dente de referencia (igual para as injecoes 1 e 4) */
int tempo_bob; /* tempo de carregamento da bobina de ign */
int tempo_inj; /* tempo de injecao */
float t_inj_real, controle_lambda = 0;
float controle_lambda_ant = 0;
float t_inj_lim;
int t_inj_extra;
int ij_dente_14_temp;
static int ij_dente_14_extra;

/*___________________________________________ Sensores ___________________________________________________*/
unsigned int cont_partida = 1000;
char estado_temp_ml = 0;
int map; //para leitura do sensor map
float pressao_ar, pressao_ar_10bits;
long VarTest = 0;
static int sensor_t_agua;
float rs;
int t_agua; // temperatura da agua
int estado_controle_ml = 0; // vari�vel que define o estado do controle de avan�o de igni��o
float t_ar; // temperatura do ar
int t_ar_com;
float m_ar; //Rotina ECU Freescale
float m_comb, delta_estequiometria, corr_mc_ma;
unsigned int porcentagem_alcool=100; //Rotina ECU Freescale
int derivada_pedal = 0, pedal_ad, controle_lbd_int = 0;
unsigned char VoltBattery, lambda = 0, flag = 0;
float fator_corr_vbat;
float Battery;
float fator_inj, fator_inj_derivada = 0;
unsigned int sensor_t_ar;
unsigned char chave_geral_control_lambda = 0;

unsigned char buffer_i2[20];

char teste;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*_______________________________________ Variables TIMER 3 _______________________________________________*/
float ig_tmr_disparo_temp, ij_tmr_disparo_temp, tempo_inj_temp, kp_inj = 1.0 /*tempo_bob_temp*/; //Original era float
//long int    tempo_inj_temp;
unsigned int tempo_bob_temp;
float tempo_inj_temp_1;
unsigned int counter_peralta = 0;
int ig_dente_14_temp; // dente de referencia para a subida do sinal PMS CIL1 E 4
int ij_dente_14_temp; // dente de referencia para a subida do sinal
float rotacao_temp;
float periodo_52;
float ij_14_temp;
float ig_14_temp, dente_flex, ref_vb_float;
int n; // Dentes para adiantar em relacao ao tabelado
int n_e;
unsigned int ref_torque = 0, ref_torque_ant = 0, abertura_vb;
unsigned long abertura_vb_max = 0;
float ij_14_extra;
float rotacao_temp_1;

/*******************************************************************************************/
//Controle de RPM                                                                          //
//const float Kref1 = (TPS_6000-TPS_1000) /(PEDAL_MAX-PEDAL_MIN);                          //
//const float Kref2 = -(PEDAL_MIN*(TPS_6000-TPS_1000) /(PEDAL_MAX-PEDAL_MIN)) + TPS_1000;  //
/*******************************************************************************************/

/*_________________________________ Variaveis utilizadas no algoritmo PI - Injecao _________________________*/
const float Kp_inj = 0.004; //0.0006; // 0.00012;

/*_______________________ Variaveis utilizados no algoritmo PI - Controle de Rotacao _______________________*/
float ref_rpm; // Sinal de referencia (pedal convertido p/ escala de RPM)
float erro_rpm;
float soma_erro_rpm;
float Kp_rpm; // Anterior: constante = 2.0
const float Ki_rpm = 0.00002; // Anterior: 0.00012     //HIROKI = 0.00002
unsigned char injecao_ok; //Testar comando
int ref_vb; // Sinal de referencia (pedal convertido p/ escala da vb
float Kref1_rpm;
float Kref2_rpm;
float ref_vb_max, ref_vb_max_peralta;
float ref_vb_base;
long int temp;
short int dm;
float contro_lambda = 0;

int ATUALref_vb = 35;
int ANTref_vb = 35;

unsigned int AD_Req = 0;
short Send_i2c = 0;
unsigned char OffSet_refRPM = 0;
unsigned char flag_disturbio = 0;
short Flag_MarchaLenta = 0;
short flag_controle_ign = 0;

int flag_partida = 1;

/********************************Variaveis I2c********************************/
unsigned char buffer_i2c[50];

typedef enum
{
    enReleInit = 0,
    enRele_1 = enReleInit,
    enRele_2,
    enRele_3,
    enRele_4,
    enRele_5,
    enRele_6,
    enRele_7,
    enRele_8,
    enReleMax
} EnumReles;

static union
{
    unsigned int u8All;

    struct
    {
        unsigned Rele1 : 1;
        unsigned Rele2 : 1;
        unsigned Rele3 : 1;
        unsigned Rele4 : 1;
        unsigned Rele5 : 1;
        unsigned Rele6 : 1;
        unsigned Rele7 : 1;
        unsigned Rele8 : 1;
    } StatusAllReles;
} UnionAllReles;

/*ex: SetBit(UnionAllReles.u8aAll, enRele_1)*/
#define SetBit(value,Bit)		((value) |= (1 << (Bit)))

/*ex: GetBit(UnionAllReles.u8aAll, enRele_1)*/
#define GetBit(value,Bit)		((value) >> (Bit) & 0x01)

/*ex: ClearBit(UnionAllReles.u8aAll, enRele_1)*/
void ClearBit(unsigned char *value, unsigned char Bit)
{
    unsigned char aux = (1 << (Bit));
    *value = *value & (unsigned char) (~aux);
}

void map_ad_Read();
void t_ar_ad_Read();
void lambda_Read();
void control_lambda();
void t_agua_ad_Read();
void pedal_ad_Read();
void Battery_ad_Read();
inline void controle_rpm();
void Spi_Write16(unsigned int data);
void Spi2_Write16(unsigned int data);
inline void conta_dente();

/*______________________________________ MAP DENTE_IG14 _________________________________________________________________*/
//const float ig_refGOL[66][10] = {
//    { 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00}, /*000 rpm*/
//    { 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50}, /*100 rpm*/
//    { 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50}, /*200 rpm*/
//    { 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50, 14.50}, /*300 rpm*/
//    { 14.10, 14.10, 14.10, 14.10, 14.10, 14.10, 14.10, 14.10, 14.10, 14.10}, /*400 rpm*/
//    { 13.10, 13.10, 13.10, 13.10, 13.10, 13.10, 13.10, 13.10, 13.10, 13.10}, /*500 rpm*/
//    { 13.10, 13.10, 13.10, 13.10, 13.10, 13.10, 13.10, 13.10, 13.10, 13.10}, /*600 rpm*/
//    { 12.50, 12.50, 12.33, 12.33, 12.33, 12.33, 12.33, 12.33, 12.33, 12.33}, /*700 rpm*/
//    { 12.53, 12.54, 12.21, 12.21, 12.23, 12.23, 12.23, 12.23, 12.34, 12.38}, /*800 rpm*/
//    { 12.54, 12.55, 12.11, 12.11, 12.14, 12.14, 12.14, 12.14, 12.34, 12.41}, /*900 rpm*/
//    { 12.52, 12.53, 12.02, 12.03, 12.05, 12.05, 12.05, 12.05, 12.31, 12.42}, /*1000 rpm*/
//    { 12.47, 12.48, 11.95, 11.95, 11.97, 11.97, 11.97, 11.97, 12.28, 12.40}, /*1100 rpm*/
//    { 12.41, 12.41, 11.88, 11.89, 11.90, 11.90, 11.90, 11.90, 12.23, 12.37}, /*1200 rpm*/
//    { 12.33, 12.33, 11.83, 11.83, 11.83, 11.83, 11.83, 11.83, 12.17, 12.33}, /*1300 rpm*/
//    { 12.23, 12.23, 11.78, 11.78, 11.77, 11.77, 11.77, 11.77, 12.10, 12.27}, /*1400 rpm*/
//    { 12.13, 12.12, 11.74, 11.73, 11.71, 11.71, 11.71, 11.71, 12.03, 12.21}, /*1500 rpm*/
//    { 12.01, 12.00, 11.69, 11.69, 11.66, 11.66, 11.66, 11.66, 11.96, 12.14}, /*1600 rpm*/
//    { 11.88, 11.88, 11.65, 11.65, 11.61, 11.61, 11.61, 11.61, 11.88, 12.06}, /*1700 rpm*/
//    { 11.76, 11.75, 11.61, 11.60, 11.57, 11.57, 11.57, 11.57, 11.81, 11.98}, /*1800 rpm*/
//    { 11.63, 11.62, 11.56, 11.55, 11.53, 11.53, 11.53, 11.53, 11.74, 11.91}, /*1900 rpm*/
//    { 11.50, 11.50, 11.50, 11.50, 11.50, 11.50, 11.50, 11.50, 11.67, 11.83}, /*2000 rpm*/
//    { 11.38, 11.38, 11.44, 11.44, 11.47, 11.47, 11.47, 11.47, 11.61, 11.76}, /*2100 rpm*/
//    { 11.26, 11.28, 11.36, 11.38, 11.45, 11.45, 11.45, 11.45, 11.56, 11.69}, /*2200 rpm*/
//    { 11.14, 11.17, 11.28, 11.31, 11.43, 11.43, 11.43, 11.43, 11.52, 11.63}, /*2300 rpm*/
//    { 11.02, 11.07, 11.20, 11.24, 11.41, 11.41, 11.41, 11.41, 11.48, 11.57}, /*2400 rpm*/
//    { 10.91, 10.98, 11.11, 11.16, 11.39, 11.39, 11.39, 11.39, 11.44, 11.52}, /*2500 rpm*/
//    { 10.79, 10.88, 11.02, 11.09, 11.37, 11.37, 11.37, 11.37, 11.41, 11.47}, /*2600 rpm*/
//    { 10.68, 10.79, 10.93, 11.02, 11.36, 11.36, 11.36, 11.36, 11.38, 11.42}, /*2700 rpm*/
//    { 10.56, 10.69, 10.84, 10.95, 11.34, 11.34, 11.34, 11.34, 11.35, 11.38}, /*2800 rpm*/
//    { 10.45, 10.60, 10.76, 10.89, 11.32, 11.32, 11.32, 11.32, 11.33, 11.34}, /*2900 rpm*/
//    { 10.33, 10.50, 10.67, 10.83, 11.30, 11.30, 11.30, 11.30, 11.30, 11.30}, /*3000 rpm*/
//    { 10.21, 10.40, 10.59, 10.78, 11.28, 11.28, 11.28, 11.28, 11.27, 11.26}, /*3100 rpm*/
//    { 10.09, 10.30, 10.51, 10.73, 11.25, 11.25, 11.25, 11.25, 11.24, 11.23}, /*3200 rpm*/
//    { 9.96, 10.19, 10.44, 10.70, 11.22, 11.22, 11.22, 11.22, 11.21, 11.19}, /*3300 rpm*/
//    { 9.84, 10.09, 10.37, 10.66, 11.19, 11.19, 11.19, 11.19, 11.18, 11.16}, /*3400 rpm*/
//    { 9.72, 9.98, 10.30, 10.63, 11.16, 11.16, 11.16, 11.16, 11.15, 11.13}, /*3500 rpm*/
//    { 9.60, 9.88, 10.23, 10.60, 11.13, 11.13, 11.13, 11.13, 11.12, 11.10}, /*3600 rpm*/
//    { 9.48, 9.78, 10.17, 10.58, 11.10, 11.10, 11.10, 11.10, 11.09, 11.08}, /*3700 rpm*/
//    { 9.37, 9.68, 10.11, 10.55, 11.06, 11.06, 11.06, 11.06, 11.06, 11.05}, /*3800 rpm*/
//    { 9.27, 9.59, 10.06, 10.53, 11.03, 11.03, 11.03, 11.03, 11.03, 11.02}, /*3900 rpm*/
//    { 9.17, 9.50, 10.00, 10.50, 11.00, 11.00, 11.00, 11.00, 11.00, 11.00}, /*4000 rpm*/
//    { 9.08, 9.42, 9.95, 10.47, 10.97, 10.97, 10.97, 10.97, 10.97, 10.98}, /*4100 rpm*/
//    { 9.00, 9.35, 9.89, 10.44, 10.94, 10.94, 10.94, 10.94, 10.94, 10.95}, /*4200 rpm*/
//    { 8.93, 9.28, 9.84, 10.41, 10.91, 10.91, 10.91, 10.91, 10.92, 10.93}, /*4300 rpm*/
//    { 8.87, 9.23, 9.79, 10.37, 10.89, 10.89, 10.89, 10.89, 10.90, 10.91}, /*4400 rpm*/
//    { 8.83, 9.19, 9.74, 10.33, 10.86, 10.86, 10.86, 10.86, 10.87, 10.89}, /*4500 rpm*/
//    { 8.80, 9.16, 9.70, 10.28, 10.84, 10.84, 10.84, 10.84, 10.85, 10.87}, /*4600 rpm*/
//    { 8.78, 9.14, 9.65, 10.22, 10.83, 10.83, 10.83, 10.83, 10.84, 10.85}, /*4700 rpm*/
//    { 8.78, 9.13, 9.60, 10.16, 10.81, 10.81, 10.81, 10.81, 10.82, 10.84}, /*4800 rpm*/
//    { 8.80, 9.14, 9.55, 10.08, 10.80, 10.80, 10.80, 10.80, 10.81, 10.82}, /*4900 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5000 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5100 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5200 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5400 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5500 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5600 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5700 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5800 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5900 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6000 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6100 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6200 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6300 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6400 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6500 rpm*/
//    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}
//}; /*6600 rpm*/

//const float ig_refGOL[66][10] = {
//    { 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00}, /*000 rpm*/
//    { 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00}, /*100 rpm*/
//    { 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00}, /*200 rpm*/
//    { 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00}, /*300 rpm*/
//    { 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00, 14.00}, /*400 rpm*/
//    { 13.70, 13.70, 13.70, 13.68, 13.68, 13.68, 13.68, 13.68, 13.68, 13.68}, /*500 rpm*/
//    { 13.64, 13.64, 13.64, 13.60, 13.60, 13.59, 13.59, 13.60, 13.59, 13.59}, /*600 rpm*/
//    { 13.58, 13.58, 13.58, 13.53, 13.53, 13.53, 13.53, 13.53, 13.53, 13.53}, /*700 rpm*/
//    { 13.55, 13.55, 13.55, 13.50, 13.50, 13.50, 13.50, 13.50, 13.50, 13.50}, /*800 rpm*/
//    { 13.59, 13.59, 13.58, 13.53, 13.53, 13.52, 13.52, 13.53, 13.53, 13.53}, /*900 rpm*/
//    { 13.55, 13.55, 13.55, 13.50, 13.50, 13.50, 13.50, 13.50, 13.50, 13.50}, /*1000 rpm*/
//    { 13.31, 13.30, 13.34, 13.29, 13.29, 13.33, 13.33, 13.30, 13.33, 13.33}, /*1100 rpm*/
//    { 12.89, 12.88, 12.99, 12.94, 12.94, 13.04, 13.04, 12.98, 13.03, 13.03}, /*1200 rpm*/
//    { 12.38, 12.37, 12.54, 12.50, 12.50, 12.67, 12.67, 12.58, 12.67, 12.67}, /*1300 rpm*/
//    { 11.85, 11.84, 12.06, 12.04, 12.04, 12.27, 12.27, 12.19, 12.31, 12.31}, /*1400 rpm*/
//    { 11.38, 11.38, 11.63, 11.63, 11.63, 11.88, 11.88, 11.88, 12.00, 12.00}, /*1500 rpm*/
//    { 11.01, 11.04, 11.27, 11.30, 11.30, 11.53, 11.53, 11.68, 11.79, 11.79}, /*1600 rpm*/
//    { 10.77, 10.83, 11.00, 11.06, 11.06, 11.25, 11.25, 11.59, 11.66, 11.66}, /*1700 rpm*/
//    { 10.61, 10.71, 10.82, 10.89, 10.90, 11.03, 11.02, 11.55, 11.59, 11.59}, /*1800 rpm*/
//    { 10.53, 10.66, 10.71, 10.80, 10.80, 10.86, 10.86, 11.54, 11.55, 11.55}, /*1900 rpm*/
//    { 10.50, 10.67, 10.67, 10.75, 10.75, 10.75, 10.75, 11.50, 11.50, 11.50}, /*2000 rpm*/
//    { 10.51, 10.69, 10.68, 10.74, 10.74, 10.70, 10.70, 11.41, 11.43, 11.43}, /*2100 rpm*/
//    { 10.53, 10.73, 10.73, 10.75, 10.76, 10.69, 10.71, 11.29, 11.34, 11.35}, /*2200 rpm*/
//    { 10.55, 10.75, 10.78, 10.77, 10.78, 10.72, 10.74, 11.15, 11.25, 11.26}, /*2300 rpm*/
//    { 10.54, 10.73, 10.79, 10.77, 10.81, 10.77, 10.80, 11.04, 11.18, 11.18}, /*2400 rpm*/
//    { 10.50, 10.67, 10.75, 10.75, 10.83, 10.83, 10.88, 10.96, 11.13, 11.13}, /*2500 rpm*/
//    { 10.40, 10.54, 10.63, 10.68, 10.83, 10.90, 10.94, 10.94, 11.11, 11.10}, /*2600 rpm*/
//    { 10.27, 10.37, 10.45, 10.59, 10.80, 10.96, 11.00, 10.96, 11.12, 11.11}, /*2700 rpm*/
//    { 10.12, 10.18, 10.24, 10.47, 10.75, 11.00, 11.04, 11.01, 11.14, 11.12}, /*2800 rpm*/
//    { 9.98, 10.01, 10.04, 10.34, 10.66, 11.00, 11.04, 11.04, 11.14, 11.13}, /*2900 rpm*/
//    { 9.88, 9.88, 9.88, 10.21, 10.54, 10.96, 11.00, 11.04, 11.13, 11.13}, /*3000 rpm*/
//    { 9.81, 9.80, 9.77, 10.09, 10.39, 10.86, 10.92, 10.99, 11.07, 11.09}, /*3100 rpm*/
//    { 9.78, 9.77, 9.73, 10.00, 10.22, 10.73, 10.80, 10.91, 10.99, 11.05}, /*3200 rpm*/
//    { 9.78, 9.76, 9.72, 9.92, 10.06, 10.58, 10.67, 10.80, 10.90, 10.99}, /*3300 rpm*/
//    { 9.77, 9.76, 9.73, 9.86, 9.92, 10.42, 10.55, 10.70, 10.81, 10.93}, /*3400 rpm*/
//    { 9.75, 9.75, 9.75, 9.83, 9.83, 10.29, 10.46, 10.63, 10.75, 10.88}, /*3500 rpm*/
//    { 9.71, 9.71, 9.77, 9.83, 9.81, 10.20, 10.41, 10.59, 10.72, 10.84}, /*3600 rpm*/
//    { 9.65, 9.66, 9.78, 9.86, 9.84, 10.14, 10.40, 10.59, 10.73, 10.82}, /*3700 rpm*/
//    { 9.61, 9.61, 9.81, 9.91, 9.93, 10.13, 10.43, 10.62, 10.76, 10.82}, /*3800 rpm*/
//    { 9.59, 9.59, 9.87, 10.00, 10.05, 10.17, 10.49, 10.68, 10.81, 10.84}, /*3900 rpm*/
//    { 9.63, 9.63, 9.96, 10.13, 10.21, 10.25, 10.58, 10.75, 10.88, 10.88}, /*4000 rpm*/
//    { 9.72, 9.72, 10.09, 10.28, 10.39, 10.38, 10.69, 10.84, 10.94, 10.92}, /*4100 rpm*/
//    { 9.86, 9.86, 10.25, 10.45, 10.57, 10.54, 10.82, 10.92, 11.00, 10.98}, /*4200 rpm*/
//    { 10.03, 10.03, 10.42, 10.61, 10.75, 10.71, 10.94, 11.01, 11.05, 11.04}, /*4300 rpm*/
//    { 10.21, 10.21, 10.58, 10.76, 10.90, 10.87, 11.04, 11.08, 11.10, 11.09}, /*4400 rpm*/
//    { 10.38, 10.38, 10.71, 10.88, 11.00, 11.00, 11.13, 11.13, 11.13, 11.13}, /*4500 rpm*/
//    { 10.50, 10.50, 10.79, 10.93, 11.04, 11.07, 11.17, 11.14, 11.13, 11.14}, /*4600 rpm*/
//    { 10.58, 10.58, 10.80, 10.92, 11.00, 11.07, 11.17, 11.12, 11.12, 11.13}, /*4700 rpm*/
//    { 10.57, 10.57, 10.73, 10.81, 10.87, 10.98, 11.10, 11.06, 11.07, 11.09}, /*4800 rpm*/
//    { 10.47, 10.47, 10.55, 10.59, 10.63, 10.77, 10.97, 10.93, 10.99, 11.01}, /*4900 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5000 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5100 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5200 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5300 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5400 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5500 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5600 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5700 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5800 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*5900 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*6000 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*6100 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*6200 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*6300 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}, /*6400 rpm*/
//    { 10.25, 10.25, 10.25, 10.25, 10.25, 10.42, 10.75, 10.75, 10.88, 10.88}
//}; /*6500 rpm*/

const float ig_refGOL_Alcool[66][10] = {
    { 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
    { 10.86, 10.97, 10.98, 11.16, 11.16, 11.16, 11.50, 11.49, 11.47, 11.46},
    { 10.50, 10.75, 10.79, 11.17, 11.17, 11.17, 11.50, 11.50, 11.50, 11.50},
    { 10.31, 10.65, 10.78, 11.19, 11.21, 11.21, 11.50, 11.55, 11.68, 11.72},
    { 10.27, 10.64, 10.90, 11.20, 11.27, 11.26, 11.48, 11.61, 11.98, 12.07},
    { 10.33, 10.69, 11.07, 11.18, 11.30, 11.29, 11.43, 11.65, 12.32, 12.44},
    { 10.43, 10.74, 11.17, 11.08, 11.26, 11.26, 11.32, 11.61, 12.63, 12.73},
    { 10.50, 10.75, 11.13, 10.88, 11.13, 11.13, 11.13, 11.46, 12.83, 12.83},
    { 10.50, 10.68, 10.85, 10.54, 10.86, 10.87, 10.84, 11.17, 12.88, 12.68},
    { 10.45, 10.56, 10.41, 10.12, 10.50, 10.53, 10.50, 10.77, 12.79, 12.33},
    { 10.38, 10.42, 9.89, 9.65, 10.07, 10.14, 10.13, 10.33, 12.59, 11.90},
    { 10.33, 10.27, 9.38, 9.19, 9.61, 9.74, 9.77, 9.90, 12.31, 11.48},
    { 10.33, 10.17, 8.96, 8.79, 9.17, 9.38, 9.46, 9.54, 12.00, 11.17},
    { 10.41, 10.12, 8.69, 8.48, 8.77, 9.08, 9.22, 9.29, 11.68, 11.04},
    { 10.53, 10.12, 8.55, 8.27, 8.43, 8.86, 9.05, 9.12, 11.36, 11.05},
    { 10.67, 10.14, 8.48, 8.14, 8.17, 8.71, 8.93, 9.02, 11.06, 11.13},
    { 10.78, 10.16, 8.42, 8.08, 8.01, 8.60, 8.83, 8.95, 10.77, 11.19},
    { 10.83, 10.17, 8.33, 8.08, 7.96, 8.54, 8.75, 8.88, 10.50, 11.17},
    { 10.80, 10.14, 8.17, 8.14, 8.02, 8.52, 8.67, 8.78, 10.27, 11.01},
    { 10.70, 10.09, 7.96, 8.22, 8.17, 8.52, 8.59, 8.68, 10.09, 10.77},
    { 10.57, 10.04, 7.74, 8.32, 8.34, 8.53, 8.52, 8.59, 10.00, 10.52},
    { 10.44, 10.00, 7.56, 8.40, 8.48, 8.54, 8.47, 8.52, 10.02, 10.35},
    { 10.33, 10.00, 7.46, 8.46, 8.54, 8.54, 8.46, 8.50, 10.17, 10.33},
    { 10.28, 10.04, 7.46, 8.46, 8.49, 8.52, 8.48, 8.53, 10.46, 10.52},
    { 10.27, 10.12, 7.53, 8.42, 8.35, 8.47, 8.53, 8.59, 10.85, 10.85},
    { 10.29, 10.20, 7.63, 8.32, 8.16, 8.41, 8.58, 8.67, 11.25, 11.24},
    { 10.32, 10.28, 7.70, 8.17, 7.94, 8.33, 8.62, 8.73, 11.60, 11.60},
    { 10.33, 10.33, 7.71, 7.96, 7.75, 8.25, 8.63, 8.75, 11.83, 11.83},
    { 10.33, 10.35, 7.62, 7.71, 7.61, 8.17, 8.59, 8.72, 11.89, 11.88},
    { 10.31, 10.33, 7.49, 7.47, 7.55, 8.11, 8.55, 8.66, 11.80, 11.78},
    { 10.29, 10.31, 7.41, 7.32, 7.60, 8.13, 8.54, 8.63, 11.62, 11.59},
    { 10.30, 10.31, 7.46, 7.34, 7.79, 8.24, 8.59, 8.67, 11.39, 11.36},
    { 10.33, 10.33, 7.71, 7.58, 8.13, 8.50, 8.75, 8.83, 11.17, 11.17},
    { 10.41, 10.41, 8.21, 8.10, 8.63, 8.91, 9.04, 9.14, 10.99, 11.04},
    { 10.52, 10.51, 8.89, 8.80, 9.23, 9.43, 9.41, 9.53, 10.86, 10.98},
    { 10.64, 10.63, 9.63, 9.57, 9.85, 9.97, 9.82, 9.97, 10.76, 10.97},
    { 10.75, 10.75, 10.31, 10.29, 10.41, 10.46, 10.20, 10.36, 10.70, 10.98},
    { 10.83, 10.83, 10.83, 10.83, 10.83, 10.83, 10.50, 10.67, 10.67, 11.00},
    { 10.88, 10.88, 11.11, 11.12, 11.05, 11.03, 10.68, 10.82, 10.65, 11.01},
    { 10.89, 10.89, 11.17, 11.19, 11.10, 11.07, 10.75, 10.86, 10.64, 11.01},
    { 10.87, 10.88, 11.10, 11.11, 11.05, 11.02, 10.75, 10.82, 10.65, 11.01},
    { 10.85, 10.85, 10.96, 10.97, 10.94, 10.93, 10.71, 10.74, 10.66, 11.00},
    { 10.83, 10.83, 10.83, 10.83, 10.83, 10.83, 10.67, 10.67, 10.67, 11.00},
    { 10.83, 10.83, 10.76, 10.76, 10.78, 10.79, 10.65, 10.63, 10.68, 11.00},
    { 10.83, 10.83, 10.75, 10.75, 10.77, 10.78, 10.64, 10.62, 10.68, 11.00},
    { 10.83, 10.83, 10.77, 10.77, 10.78, 10.79, 10.65, 10.64, 10.68, 11.01},
    { 10.84, 10.84, 10.81, 10.80, 10.81, 10.82, 10.66, 10.66, 10.68, 11.01},
    { 10.83, 10.83, 10.83, 10.83, 10.83, 10.83, 10.67, 10.67, 10.67, 11.00},
    { 10.82, 10.82, 10.84, 10.84, 10.84, 10.83, 10.66, 10.66, 10.65, 10.99},
    { 10.81, 10.81, 10.83, 10.83, 10.82, 10.82, 10.64, 10.65, 10.63, 10.98},
    { 10.80, 10.80, 10.82, 10.82, 10.81, 10.81, 10.63, 10.63, 10.62, 10.97},
    { 10.80, 10.80, 10.82, 10.82, 10.81, 10.81, 10.63, 10.64, 10.63, 10.97},
    { 10.83, 10.83, 10.83, 10.83, 10.83, 10.83, 10.67, 10.67, 10.67, 11.00},
    { 10.90, 10.90, 10.88, 10.88, 10.89, 10.89, 10.74, 10.74, 10.75, 11.05},
    { 11.00, 11.00, 10.98, 10.98, 10.99, 10.99, 10.87, 10.86, 10.88, 11.14},
    { 11.16, 11.16, 11.14, 11.13, 11.14, 11.14, 11.06, 11.05, 11.07, 11.26},
    { 11.38, 11.38, 11.36, 11.36, 11.36, 11.37, 11.32, 11.31, 11.33, 11.44}
};

const float ig_refGOL[66][10] = {
    { 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00}, /*000 rpm*/
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
{	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	,	11.50	},
    { 13.55, 13.55, 13.55, 13.50, 13.50, 13.50, 13.50, 13.50, 13.50, 13.50}, /*1000 rpm*/
    { 13.31, 13.30, 13.34, 13.29, 13.29, 13.33, 13.33, 13.30, 13.33, 13.33}, /*1100 rpm*/
    { 12.89, 12.88, 12.99, 12.94, 12.94, 13.04, 13.04, 12.98, 13.03, 13.03}, /*1200 rpm*/
    { 12.38, 12.37, 12.54, 12.50, 12.50, 12.67, 12.67, 12.58, 12.67, 12.67}, /*1300 rpm*/
    { 11.85, 11.84, 12.06, 12.04, 12.04, 12.27, 12.27, 12.19, 12.31, 12.31}, /*1400 rpm*/
    { 11.38, 11.38, 11.63, 11.63, 11.63, 11.88, 11.88, 11.88, 12.00, 12.00}, /*1500 rpm*/
    { 11.01, 11.04, 11.27, 11.30, 11.30, 11.53, 11.53, 11.68, 11.79, 11.79}, /*1600 rpm*/
    { 10.77, 10.83, 11.00, 11.06, 11.06, 11.25, 11.25, 11.59, 11.66, 11.66}, /*1700 rpm*/
    { 10.61, 10.71, 10.82, 10.89, 10.90, 11.03, 11.02, 11.55, 11.59, 11.59}, /*1800 rpm*/
    { 10.53, 10.66, 10.71, 10.80, 10.80, 10.86, 10.86, 11.54, 11.55, 11.55}, /*1900 rpm*/
    { 11.50, 11.50, 11.50, 11.50, 11.50, 11.50, 11.50, 11.50, 11.67, 11.83}, /*2000 rpm*/
    { 11.38, 11.38, 11.44, 11.44, 11.47, 11.47, 11.47, 11.47, 11.61, 11.76}, /*2100 rpm*/
    { 11.26, 11.28, 11.36, 11.38, 11.45, 11.45, 11.45, 11.45, 11.56, 11.69}, /*2200 rpm*/
    { 11.14, 11.17, 11.28, 11.31, 11.43, 11.43, 11.43, 11.43, 11.52, 11.63}, /*2300 rpm*/
    { 11.02, 11.07, 11.20, 11.24, 11.41, 11.41, 11.41, 11.41, 11.48, 11.57}, /*2400 rpm*/
    { 10.91, 10.98, 11.11, 11.16, 11.39, 11.39, 11.39, 11.39, 11.44, 11.52}, /*2500 rpm*/
    { 10.79, 10.88, 11.02, 11.09, 11.37, 11.37, 11.37, 11.37, 11.41, 11.47}, /*2600 rpm*/
    { 10.68, 10.79, 10.93, 11.02, 11.36, 11.36, 11.36, 11.36, 11.38, 11.42}, /*2700 rpm*/
    { 10.56, 10.69, 10.84, 10.95, 11.34, 11.34, 11.34, 11.34, 11.35, 11.38}, /*2800 rpm*/
    { 10.45, 10.60, 10.76, 10.89, 11.32, 11.32, 11.32, 11.32, 11.33, 11.34}, /*2900 rpm*/
    { 10.33, 10.50, 10.67, 10.83, 11.30, 11.30, 11.30, 11.30, 11.30, 11.30}, /*3000 rpm*/
    { 10.21, 10.40, 10.59, 10.78, 11.28, 11.28, 11.28, 11.28, 11.27, 11.26}, /*3100 rpm*/
    { 10.09, 10.30, 10.51, 10.73, 11.25, 11.25, 11.25, 11.25, 11.24, 11.23}, /*3200 rpm*/
    { 9.96, 10.19, 10.44, 10.70, 11.22, 11.22, 11.22, 11.22, 11.21, 11.19}, /*3300 rpm*/
    { 9.84, 10.09, 10.37, 10.66, 11.19, 11.19, 11.19, 11.19, 11.18, 11.16}, /*3400 rpm*/
    { 9.72, 9.98, 10.30, 10.63, 11.16, 11.16, 11.16, 11.16, 11.15, 11.13}, /*3500 rpm*/
    { 9.60, 9.88, 10.23, 10.60, 11.13, 11.13, 11.13, 11.13, 11.12, 11.10}, /*3600 rpm*/
    { 9.48, 9.78, 10.17, 10.58, 11.10, 11.10, 11.10, 11.10, 11.09, 11.08}, /*3700 rpm*/
    { 9.37, 9.68, 10.11, 10.55, 11.06, 11.06, 11.06, 11.06, 11.06, 11.05}, /*3800 rpm*/
    { 9.27, 9.59, 10.06, 10.53, 11.03, 11.03, 11.03, 11.03, 11.03, 11.02}, /*3900 rpm*/
    { 9.17, 9.50, 10.00, 10.50, 11.00, 11.00, 11.00, 11.00, 11.00, 11.00}, /*4000 rpm*/
    { 9.08, 9.42, 9.95, 10.47, 10.97, 10.97, 10.97, 10.97, 10.97, 10.98}, /*4100 rpm*/
    { 9.00, 9.35, 9.89, 10.44, 10.94, 10.94, 10.94, 10.94, 10.94, 10.95}, /*4200 rpm*/
    { 8.93, 9.28, 9.84, 10.41, 10.91, 10.91, 10.91, 10.91, 10.92, 10.93}, /*4300 rpm*/
    { 8.87, 9.23, 9.79, 10.37, 10.89, 10.89, 10.89, 10.89, 10.90, 10.91}, /*4400 rpm*/
    { 8.83, 9.19, 9.74, 10.33, 10.86, 10.86, 10.86, 10.86, 10.87, 10.89}, /*4500 rpm*/
    { 8.80, 9.16, 9.70, 10.28, 10.84, 10.84, 10.84, 10.84, 10.85, 10.87}, /*4600 rpm*/
    { 8.78, 9.14, 9.65, 10.22, 10.83, 10.83, 10.83, 10.83, 10.84, 10.85}, /*4700 rpm*/
    { 8.78, 9.13, 9.60, 10.16, 10.81, 10.81, 10.81, 10.81, 10.82, 10.84}, /*4800 rpm*/
    { 8.80, 9.14, 9.55, 10.08, 10.80, 10.80, 10.80, 10.80, 10.81, 10.82}, /*4900 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5000 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5100 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5200 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5400 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5500 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5600 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5700 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5800 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*5900 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6000 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6100 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6200 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6300 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6400 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}, /*6500 rpm*/
    { 8.83, 9.17, 9.50, 10.00, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80}
}; /*6600 rpm*/
//const float ij_ref[66] = { 200.00 , 12.42 , 12.42 , 12.42 , 12.42 , 12.42 , 12.42 ,
//    12.42 , 12.42 , 12.42 , 12.42 , 12.60 , 12.78 , 12.97 , 13.16 , 13.35 , 13.55 ,
//    13.75 , 13.96 , 14.16 , 14.37 , 14.58 , 14.80 , 15.01 , 15.23 , 15.44 , 15.66 ,
//    15.87 , 16.09 , 16.31 , 16.52 , 16.74 , 16.95 , 17.16 , 17.37 , 17.58 , 17.78 ,
//    17.99 , 18.19 , 18.38 , 18.57 , 18.76 , 18.94 , 19.12 , 19.30 , 19.47 , 19.63 ,
//    19.79 , 19.94 , 20.08 , 20.22 , 20.35 , 20.48 , 20.60 , 20.70 , 20.80 , 20.90 ,
//    20.98 , 21.05 , 21.12 , 21.17 , 21.22 , 21.25 , 21.28 , 21.29 , 200.00 };

const float ij_ref[66] = {200.00, 17.42, 17.42, 17.42, 17.42, 17.42, 17.42,
    17.42, 17.42, 17.42, 17.42, 17.60, 17.78, 17.97, 18.16, 18.35, 18.55,
    18.75, 18.96, 19.16, 19.37, 19.58, 19.80, 20.01, 20.23, 20.44, 20.66,
    20.87, 21.09, 21.31, 21.52, 21.74, 21.95, 22.16, 22.37, 22.58, 22.78,
    22.99, 23.19, 23.38, 23.57, 23.76, 23.94, 24.12, 24.30, 24.47, 24.63,
    24.79, 24.94, 25.08, 25.22, 25.35, 25.48, 25.60, 25.70, 25.80, 25.90,
    25.98, 26.05, 26.12, 26.17, 26.22, 26.25, 26.28, 26.29, 200.00};

//char Vet_TempAg[256] = {
//     116,107,101,98,95,92,90,88,86,85,84,83,81,80,79,78,78,77,76,75,
//     75,74,73,73,72,71,71,70,70,69,69,68,68,67,67,67,66,66,65,65,
//     65,64,64,63,63,63,62,62,62,61,61,61,60,60,60,59,59,59,59,58,
//     58,58,57,57,57,57,56,56,56,55,55,55,55,54,54,54,54,53,53,53,
//     53,52,52,52,52,52,51,51,51,51,50,50,50,50,50,49,49,49,49,48,
//     48,48,48,48,47,47,47,47,46,46,46,46,46,45,45,45,45,45,44,44,
//     44,44,44,43,43,43,43,43,42,42,42,42,41,41,41,41,41,40,40,40,
//     40,40,39,39,39,39,39,38,38,38,38,37,37,37,37,37,36,36,36,36,
//     36,35,35,35,35,34,34,34,34,33,33,33,33,33,32,32,32,32,31,31,
//     31,31,30,30,30,30,29,29,29,28,28,28,28,27,27,27,27,26,26,26,
//     25,25,25,24,24,24,23,23,23,22,22,22,21,21,21,20,20,19,19,18,
//     18,18,17,17,16,16,15,15,14,14,13,12,12,11,10,10,9,8,7,7,6,5,
//     4,3,1,0,-0,-2,-4,-6,-8,-11,-15,-21,-30};
//
//unsigned int Vet_TempAr[256] = {
//     383,374,370,366,364,361,359,358,356,355,354,353,352,351,350,349,348,348,347,346,
//     346,345,345,344,343,343,342,342,342,341,341,340,340,339,339,339,338,338,337,337,
//     337,336,336,336,335,335,335,335,334,334,334,333,333,333,333,332,332,332,331,331,
//     331,331,330,330,330,330,329,329,329,329,329,328,328,328,328,327,327,327,327,327,
//     326,326,326,326,325,325,325,325,325,324,324,324,324,324,323,323,323,323,323,322,
//     322,322,322,322,321,321,321,321,321,321,320,320,320,320,320,319,319,319,319,319,
//     318,318,318,318,318,318,317,317,317,317,317,316,316,316,316,316,316,315,315,315,
//     315,315,314,314,314,314,314,313,313,313,313,313,312,312,312,312,312,312,311,311,
//     311,311,311,310,310,310,310,310,309,309,309,309,308,308,308,308,308,307,307,307,
//     307,307,306,306,306,306,305,305,305,305,304,304,304,304,303,303,303,303,302,302,
//     302,302,301,301,301,300,300,300,300,299,299,299,298,298,298,297,297,296,296,296,
//     295,295,295,294,294,293,293,292,292,291,291,290,290,289,289,288,287,287,286,285,
//     284,283,283,282,280,279,278,277,275,273,271,268,265,260,252};

unsigned int Vet_TempAr[256] = {
    443, 430, 422, 416, 412, 408, 405, 402, 400, 398, 396, 394, 393, 391, 390, 389, 387, 386, 385, 384,
    383, 382, 381, 380, 379, 378, 378, 377, 376, 375, 375, 374, 373, 373, 372, 371, 371, 370, 369, 369,
    368, 368, 367, 367, 366, 366, 365, 365, 364, 364, 363, 363, 362, 362, 361, 361, 361, 360, 360, 359,
    359, 358, 358, 358, 357, 357, 356, 356, 356, 355, 355, 355, 354, 354, 353, 353, 353, 352, 352, 352,
    351, 351, 351, 350, 350, 350, 349, 349, 349, 348, 348, 348, 347, 347, 347, 346, 346, 346, 345, 345,
    345, 344, 344, 344, 343, 343, 343, 343, 342, 342, 342, 341, 341, 341, 340, 340, 340, 340, 339, 339,
    339, 338, 338, 338, 337, 337, 337, 336, 336, 336, 336, 335, 335, 335, 334, 334, 334, 333, 333, 333,
    333, 332, 332, 332, 331, 331, 331, 330, 330, 330, 330, 329, 329, 329, 328, 328, 328, 327, 327, 327,
    326, 326, 326, 325, 325, 325, 324, 324, 324, 323, 323, 323, 322, 322, 322, 321, 321, 321, 320, 320,
    320, 319, 319, 318, 318, 318, 317, 317, 317, 316, 316, 315, 315, 315, 314, 314, 313, 313, 312, 312,
    312, 311, 311, 310, 310, 309, 309, 308, 308, 307, 307, 306, 306, 305, 305, 304, 304, 303, 302, 302,
    301, 300, 300, 299, 298, 298, 297, 296, 295, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 284,
    283, 282, 280, 279, 277, 275, 273, 271, 268, 265, 261, 257, 251, 243, 230
};

char Vet_TempAg[256] = {
    154, 142, 135, 130, 126, 123, 121, 118, 116, 115, 113, 111, 110, 109, 107, 106, 105, 104, 103, 102,
    101, 101, 100, 99, 98, 98, 97, 96, 95, 95, 94, 94, 93, 92, 92, 91, 91, 90, 90, 89,
    89, 88, 88, 87, 87, 87, 86, 86, 85, 85, 84, 84, 84, 83, 83, 82, 82, 82, 81, 81, 81,
    80, 80, 80, 79, 79, 78, 78, 78, 77, 77, 77, 77, 76, 76, 76, 75, 75, 75, 74, 74, 74,
    73, 73, 73, 73, 72, 72, 72, 71, 71, 71, 71, 70, 70, 70, 69, 69, 69, 69, 68, 68, 68,
    68, 67, 67, 67, 66, 66, 66, 66, 65, 65, 65, 65, 64, 64, 64, 64, 63, 63, 63, 62, 62,
    62, 62, 61, 61, 61, 61, 60, 60, 60, 60, 59, 59, 59, 59, 58, 58, 58, 58, 57, 57, 57,
    56, 56, 56, 56, 55, 55, 55, 55, 54, 54, 54, 54, 53, 53, 53, 52, 52, 52, 52, 51, 51,
    51, 50, 50, 50, 50, 49, 49, 49, 48, 48, 48, 47, 47, 47, 47, 46, 46, 46, 45, 45, 45,
    44, 44, 44, 43, 43, 43, 42, 42, 41, 41, 41, 40, 40, 40, 39, 39, 38, 38, 38, 37, 37,
    36, 36, 35, 35, 35, 34, 34, 33, 33, 32, 32, 31, 30, 30, 29, 29, 28, 28, 27, 26, 26,
    25, 24, 23, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 12, 11, 9, 8, 6, 4, 2, -0, -3, -7,
    -12, -19, -30,
};

float VetBat[147] = {3.21, 3.19, 3.16, 3.14, 3.11, 3.08, 3.06, 3.03, 3.01,
    2.98, 2.96, 2.94, 2.91, 2.89, 2.86, 2.84, 2.82, 2.79,
    2.77, 2.75, 2.73, 2.70, 2.68, 2.66, 2.64, 2.62, 2.59,
    2.57, 2.55, 2.53, 2.51, 2.49, 2.47, 2.45, 2.43, 2.41,
    2.39, 2.37, 2.35, 2.33, 2.31, 2.29, 2.27, 2.25, 2.24,
    2.22, 2.20, 2.18, 2.16, 2.15, 2.13, 2.11, 2.09, 2.08,
    2.06, 2.04, 2.03, 2.01, 1.99, 1.98, 1.96, 1.94, 1.93,
    1.91, 1.90, 1.88, 1.86, 1.85, 1.83, 1.82, 1.80, 1.79,
    1.77, 1.76, 1.75, 1.73, 1.72, 1.70, 1.69, 1.68, 1.66,
    1.65, 1.63, 1.62, 1.61, 1.59, 1.58, 1.57, 1.56, 1.54,
    1.53, 1.52, 1.50, 1.49, 1.48, 1.47, 1.46, 1.44, 1.43,
    1.42, 1.41, 1.40, 1.39, 1.37, 1.36, 1.35, 1.34, 1.33,
    1.32, 1.31, 1.30, 1.29, 1.28, 1.27, 1.25, 1.24, 1.23,
    1.22, 1.21, 1.20, 1.19, 1.18, 1.17, 1.17, 1.16, 1.15,
    1.14, 1.13, 1.12, 1.11, 1.10, 1.09, 1.08, 1.07, 1.06,
    1.06, 1.05, 1.04, 1.03, 1.02, 1.01, 1.00, 1.00, 0.99,
    0.98, 0.97, 0.96};

void SPI_MASTER1_Chip() //Slecionar modo mestre
{
    SSP1CON1 = 0b00100000; //habilita modo SPI // FOSC/4 //
    SSP1STAT = 0b01000000; //pega amostras no fim do bit e a trasmiss�o ser� na borda de descida
    TRISC3 = 0; //C3 = SCK out/ C4 = SD1 in/ C5 = SDO out
    TRISC4 = 1;
    TRISC5 = 0;
}

#define Time_SPI    60 // lembrar de descomentar

/***************************************** CONFIGURA HARDWARE ***********************************/
void Configure_HW()
{
    /* Configura��o das Portas */
    TRISA = 0b00101111; //TRISA = 0b00100111;
    TRISB = 0b00111011; //TRISB = 0b11111111;
    TRISC = 0b10010000; //TRISC = 0b00010000;
    TRISD = 0b01101000; //TRISD = 0b00000000;
    TRISE = 0b00000001; //TRISE = 0b00000000;
    __delay_us(50); //Para aguardar os tris acima >> reduziu falhas
    //__delay_ms(10); //Para aguardar os tris acima >> reduziu falhas

    //ANSELA = 0b00101110;          /*0010 1110 AN0,AN1,AN2,AN4*/
    ANSELA = 0x00;
    ANSELB = 0x00;
    ANSELC = 0x00;
    ANSELD = 0x00;
    ANSELE = 0x00;
    //__delay_ms(10); //Para aguardar os tris acima >> reduziu falhas

    Config_ADC();
//    SPI_MASTER1_Chip();
//    SPI_MASTER2();
    Config_Timer0();
    Config_Timer1();
    Config_Timer2();
    PR2 = 195;
    Config_Timer3();
   // Config_Timer4();
    //TMR4IF = 0;
    //TMR4 = 0;
    Config_Int_Ext0();
}


unsigned char calibra1, calibra2;

unsigned int contTimer4 = 0, flagTimer4 = 0;
/***************************************** Interrupts *******************************************/
void interrupt high_isr(void)
{
    __EXT_INTERRUPT0__{

        // interrup��o externa RB0, para detectar falha TIMER 1 est� pegando a borda de descida( verificar no polo qual borda �)
        Disable_ExtInt(nExt_Int0); //  disabilita a interrup��o externa
        Clear_ExtInt_Flag(nFLAG_ExtInt0); //  limpa flag de interrup��o

        
        if (dente != 255)
        {
            Disable_Interrupt(nINT_TIMER1);
            Enable_Interrupt(nINT_TIMER2);
            t_periodo = Get_Timer1();
        }

        if ((t_periodo > t_periodo_ref) && (dente > 50)) // compara os per�odos, atual com anterior para detec��o de falha
        {
            /*------------------ Nova Volta -------------------------- */
            nSINAL_FALHA = nPin_HIGH; /* Sinal de Falha */
            falha_ok = 1; // detectou a falha
            dente = 0; /* Reinicia contagem dos dentes */
            nRELE_BOMB_INJ = nPin_HIGH; // liga rele da bomba
            a = b = c = d = 0; // flags para debug no proteus  para ver se o software est� chegando aqui , n�o serve pra nada na atua��o
            /*------------------ Fim Nova Volta ----------------------- */
        }

        t_periodo = t_periodo << 1; // multiplica por dois   para armazenar o valor do per�odo da falha
        t_periodo_ref = t_periodo; // atualiza o valor do per�odo  de referencia da falha

        conta_dente();

        Set_Timer1(0); // Inicia medicao do t_low
        ClearFlag_Interrupt(nFLAG_TMR1);
        Enable_Interrupt(nINT_TIMER1); // habilita a interrup��o do timer 1

        if (dente == 2) nSINAL_FALHA = nPin_LOW; /* Baixa o Pulso de Falha */

        c = 1;

        Enable_ExtInt(nExt_Int0);
    }

    __Interrupt_TMR3__ // interrup��o que calcula todos os valores do gerenciamento
    {
        Disable_Interrupt(nINT_TIMER3); // desabilita interrup��o de timer3 para que n�o estoure uma interrup��o dentro da outra
        ClearFlag_Interrupt(nFLAG_TMR3); // limpa flag de interrup��o
        //if(rotacao > 1600)  volta_i2c = 1;
//        TMR4 = 0;
//        TMR4IF = 0;
//        contTimer4 = 0;
        
        if (volta_i2c) // estado 1 da maquina: faz as leituras
        {
            //nPin_TESTE = nPin_HIGH;
            map_ad_Read();
            t_ar_ad_Read();
            t_agua_ad_Read();
            Battery_ad_Read();
            lambda_Read();
            //            if (flag == 0)
            //            {
            //
            //                nPin_TESTE = ~nPin_TESTE;
            //            }
            //            else
            //            {
            //
            //                nPin_TESTE = 0;
            //
            //            }

            if (Send_i2c)
            {
                //nLED_TEST = 0;
                //Variaveis para Sincronismo
                buffer_i2c[0] = ig_dente_14;
                buffer_i2c[1] = tempo_inj >> 8;     //...
                buffer_i2c[2] = tempo_inj & 0x00FF; //16 bits
                buffer_i2c[3] = estado_controle_ml; 
                buffer_i2c[4] = ij_dente_14;
                buffer_i2c[5] = ij_tmr_disparo >> 8;     //...
                buffer_i2c[6] = ij_tmr_disparo & 0x00FF; //16 bits
                buffer_i2c[7] = tempo_bob; 
                buffer_i2c[8] = ig_tmr_disparo; 
                buffer_i2c[9] = ij_dente_14_extra; 
                buffer_i2c[10] = t_agua;

                

                //valores para o admiss�o
                
                
                if (ref_vb == 255)ref_vb = 254;

                buffer_i2c[11] = ref_vb;
                
                // outros valores para o comunica��o
                
                buffer_i2c[12] = rotacao >> 8;     //...
                buffer_i2c[13] = rotacao & 0x00FF; //16 bits
                
                buffer_i2c[14] = map;
                
                
                buffer_i2c[15] = angulo[0];     //...
                buffer_i2c[16] = angulo[1]; //16 bits
                buffer_i2c[17] = t_ar;
                buffer_i2c[18] = lambda;
                buffer_i2c[19] = VoltBattery;
                
                nLED_TEST = 1;
                I2C_Master_Escreve_Multiplos_Endereco(ENDERECO_COMUNICACAO, buffer_i2c, DADOS_ENVIADOS, ENDERECO_GERENCIAMENTO);
//                if(flag_partida)
//                    ref_vb = 36;
                teste = 0;
                I2C_Master_Escreve_Endereco(ENDERECO_ADMISSAO, ref_vb, ENDERECO_GERENCIAMENTO);
                
                if(contCal == 0)
                    teste = I2C_Leitura_Endereco(ENDERECO_COMUNICACAO, ENDERECO_GERENCIAMENTO);
                contCal++;
                if(contCal == 1)
                    contCal = 0;
                
                if(teste == 50)
                {
                   
                    I2C_Leitura_Multiplos_Endereco(ENDERECO_COMUNICACAO, 15, ENDERECO_GERENCIAMENTO);
                    valorCalibrado =  buffer_read[0] << 8;
                    valorCalibrado |= buffer_read[1]; 
                    refVBCal = valorCalibrado;
                }
               // porcentagem_alcool = I2C_Leitura_Endereco(0x30, 0x40);
                I2C_Leitura_Multiplos_Endereco(ENDERECO_ADMISSAO, 2, ENDERECO_GERENCIAMENTO);
                angulo[0] = buffer_read[0];
                angulo[1] = buffer_read[1];
                Send_i2c = 0;
            }

            // Calculo da rotacao
            rotacao_temp_1 = 5000.0 / (float) periodo;
            rotacao_temp = rotacao_temp_1 * 1000.0;
            rotacao = (unsigned int) (rotacao_temp);

            // Calculo dos indices de referencia para leitura dos adiantamentos
            if (rotacao > 6500) address = 65;
            else address = (unsigned char) (rotacao_temp / 100);

            if (rotacao > 700)
            {
                flag_partida = 0;
                //Rotinas ECU Freescale para inje��o
                //m_ar = (1727.707/*Const_Gases*/ * pressao_ar)/t_ar; //em mg para facilitar contas
                /*
                 *1727.707 � a constante gerada pela fun��o de massa dos gases sendo para 2.0L
                 * m_ar = (1727.707*pressao_ar)/t_ar; //em mg para facilitar contas
                 *
                 * 1.6L = 1379.379
                 */

                derivada_pedal = ref_torque - ref_torque_ant;
                if (derivada_pedal > 0)
                {
                    fator_inj_derivada = derivada_pedal * 0.02;
                }
                else
                {
                    fator_inj_derivada = 0;
                }
                corr_mc_ma = 1.25 + fator_inj_derivada;



                m_ar = (Const_Gases * pressao_ar) / t_ar; //em mg para facilitar contas HIROKI
                //nPin_TESTE = 1;
                delta_estequiometria = (3.7 * porcentagem_alcool) / 100;
                m_comb = m_ar / (12.7 - delta_estequiometria); // estequiometria E25//13.3;//12.7 Rotina ECU Freescale    em mg!!!    12.7 � a estequiometria Fluxo:176.93g/min
                m_comb = m_comb *corr_mc_ma; // 1.25; // corre��o da massa de combust�vel
                
               if (chave_geral_control_lambda == 1) // chave controle geral desabilita o controle lambda caso haja alguma presen�a de dist�rbio de carga ao motor para n�o causar altera��es na rota��o
                {
                    if (flag == 1) // flag condiciona que o contrle lambda s� seja chamado caso a temperatura de opera��o da sonda seja atinjida
                    {
                        control_lambda();
                    }
                }
                else
                {
                    controle_lambda = 0;
                    //nPin_TESTE = 0;
                }
                tempo_inj_temp_1 = m_comb * Vazao_InjGOL + controle_lambda; //Teste para funcionar map variando injecao
                //m_comb = m_ar / 12.7; //Rotina ECU Freescale    em mg!!!    12.7 � a estequiometria Fluxo:176.93g/min HIROKI
                //tempo_inj_temp_1 = m_comb * Vazao_InjGOL; //Teste para funcionar map variando injecao HIROKI

                // Ajuste do fator de injecao em caso de aceleracao/desaceleracao

                fator_inj = 1.0;
                // lembrar de descomentar
                //                if (erro_rpm != 0 && ((erro_rpm < 70.0) || (erro_rpm > -70.0)))
                //                {
                //
                //                    fator_inj = fator_inj + Kp_inj*erro_rpm;
                //                }
                //else
                // {
                //  fator_inj = 1.0;
                //}
                //if (t_agua < 70.0) fator_inj += 0.30 - 0.004 * t_agua;

                // if (t_agua < 50.0) fator_inj += 0.50 - 0.004 * t_agua;


                if (t_agua < 30.0) fator_inj += 0.50 - 0.004 * t_agua;

                else if (t_agua < 30)
                    fator_inj += 0.1;

                //                if (t_agua < 30)
                //                    fator_inj += 0.1;
                //                else if (t_agua < 50)
                //                    fator_inj += (0.25 - 0.005 * t_agua);

                // ganho para tirar o motor do giro de marcha lenta

                if (rotacao > 500) // estado de pos partida
                {
                    fator_inj += Kp_inj*ref_torque;
                }
                if (rotacao < 1000 && pedal_ad > 39 && fator_inj < 1.1)
                {
                    fator_inj = 1.1;
                }

                //                derivada_pedal = ref_torque - ref_torque_ant;
                //                if (derivada_pedal > 0)
                //                {
                //                    fator_inj_derivada = derivada_pedal * 0.015;
                //                }
                //                else
                //                {
                //                    fator_inj_derivada = 0;
                //                }
                //
                //                fator_inj += fator_inj_derivada;
                // else fator_inj = 1.0;
                //                else
                //                    if (erro_rpm != 0 && ((erro_rpm > 120.0) || (erro_rpm < -120.0)))
                //                {
                //
                //                    fator_inj = fator_inj + Kp_inj * erro_rpm;
                //                    //HIROKI
                //                }

                //                if (flag == 1)
                //                {
                //                    fator_inj = fator_inj + control_lambda();
                //                }
                // Limitacao superior do fator de injecao (equivale a lambda ~ 0.71)

                if (fator_inj > 1.7) fator_inj = 1.7;


                    // Limitacao inferior do fator de injecao (equivale a lambda ~ 1.33)
                else if (fator_inj < 0.75) fator_inj = 0.75;




                /*tempo_inj_temp = (tempo_inj_temp_1 * fator_inj) * 100;*/
                tempo_inj_temp = (tempo_inj_temp_1 * fator_inj); //HIROKI
                //tempo_inj_temp = tempo_inj_temp; // altera��o bruninho, quando estavamos na fatec para estabilizar ml

                // Limita o tempo de injecao entre 2.7ms e 18.0 ms
                if (tempo_inj_temp < nMIN_TIME_INJGOL) tempo_inj_temp = (nMIN_TIME_INJGOL); //M�nimo de injecao
                else if (tempo_inj_temp > nMAX_TIME_INJGOL) tempo_inj_temp = (nMAX_TIME_INJGOL); //Maximo de inj

                // ALTERA��O PERALTA PARA TESTE DE  inje�ao

                //if (tempo_inj_temp < (nMIN_TIME_INJGOL))        tempo_inj_temp = (nMIN_TIME_INJGOL); //M�nimo de injecao HIROKI
                //else if (tempo_inj_temp > (nMAX_TIME_INJGOL))   tempo_inj_temp = (nMAX_TIME_INJGOL); //Maximo de inj     HIROKI


                // Limitacao superior do tempo de injecao com base no periodo de rotacao
                //periodo_52 = (periodo * 10.4) + (ij_ref[address] * periodo / 5.0);

                //tempo_inj_temp = 18000.0;
                //Controle da inj extra
                /*t_inj_real = (tempo_inj_temp/100);*/



                t_inj_real = tempo_inj_temp*kp_inj;

                periodo_52 = (periodo * 10.4);

                if (tempo_inj_temp > periodo_52)
                {
                    /*tempo_inj_temp = (long int)(periodo_52 * 100);*/
                    tempo_inj_temp = periodo_52;
                    t_inj_lim = (tempo_inj_temp);

                    t_inj_extra = (int) (t_inj_real - t_inj_lim);
                }
                else t_inj_extra = 0.0;

                // Calculo do tempo de carregamento da bobina de ign
                tempo_bob_temp = Bob_TimingGOL; //HIROKI

                //Flag_MarchaLenta = 0;
            }
            else
            {
                flag_partida = 1;
                //tempo_inj_temp = 12000.0; //Ajustar para subir giro>> Pegou de primeira com o motor quente

                //tempo_inj_temp = (11000.0 /* * 100*/); //Ajustar para subir giro com motor quente
                tempo_inj_temp = (10000); //HIROKI

                //tempo_bob_temp = 8000.0; //Apenas eleva o tempo de carga da bobina tempo = 8ms;
                tempo_bob_temp = 6000; //HIROKI

                //ref_vb = 40.0; // Abertura Inicial p/ o motor pegar (pr� partida)
            }
            // nPin_TESTE = 0;
        }
        else //Volta_i2c// maquina de estado dois
        {
          //  nLED_TEST = 1; 
            // nPin_TESTE = nPin_HIGH; // pino de teste para ver se ele estava chegando aqui // pino de teste para ver o tempo de processamento
            // nPin_TESTE = ~nPin_TESTE;
            if (rotacao < 500) ref_vb = 36;//ref_vb = 42; //nTPS_MIN; // alterado por PERALTA
            if (rotacao > 4000) tempo_bob_temp = 4000.0;

            /* Le os avancos da memoria de programa */
            address = (unsigned char) (rotacao_temp * 0.01);

            if (pressao_ar < 30.0) address_2 = 0; // se a press�o do ar for menor do que 30  o �ndice � zerado(altas rota��es)
            else if (pressao_ar > 120.0) address_2 = 9; // se for maior do que 120 o �ndice vai para o valor m�ximo(baixas rota��es))
            else address_2 = (unsigned char) ((pressao_ar / 10) - 3); //caso n�o esteja nos extremos ele faz a conta para achar o �ndice

            // Calculo dos adiantamentos - IGN e INJ
            periodo = periodo / 5.0;
            n = (tempo_inj_temp) / periodo; // n = porcentagem de um dente
            ij_14_temp = ij_ref[address] - n - 1.0;

            if (ij_14_temp < 1.0) ij_14_temp += 60.0;

            ij_dente_14_temp = (int) ij_14_temp;

            if ((ij_dente_14_temp == 59) || (ij_dente_14_temp >= 60)) ij_dente_14_temp = 58; // Para o caso em que o sinal sobe na falha
            else if ((ij_dente_14_temp == 29) || (ij_dente_14_temp == 30)) ij_dente_14_temp = 28; // Para o caso em que o sinal de inj 23 sobe na falha

            ij_tmr_disparo_temp = (ij_14_temp - (float) ij_dente_14_temp) * periodo;

            //Dente de inje��o extra
            if ((t_inj_extra > 0.0) && (rotacao > 2600))
            {
                n_e = t_inj_extra / periodo;
                ij_14_extra = ij_14_temp - n_e;

                if (ij_14_extra < 1.0) ij_14_extra = 1.0;
                if (ij_14_extra > 28.0) ij_14_extra = 28.0;

                ij_dente_14_extra = (int) ij_14_extra;
            }
            else ij_dente_14_extra = 0;

            //AQUI ESTA O DENTE WILLIAM - MARCUS
            dente_flex = ig_refGOL[address][address_2]*(100 - porcentagem_alcool) / 100 + ig_refGOL_Alcool[address][address_2]*(porcentagem_alcool / 100);




            n = tempo_bob_temp / periodo; // faz o c�lculo para saber quantos dentes cabem no per�odo de acionamento da bobina
            //ig_14_temp = ig_refGOL[address][address_2] - n; // aqui ele faz o c�lculo para poder acionar a bobina de modo que
            ig_14_temp = dente_flex - n;
            // quando ela descarregar o pulso seja dado em cima do dente de referencia

            if (ig_14_temp < 1.0) ig_14_temp += 60.0;

            //            /*degrau no avan�o de igni��o para identifica��o do modelo do motor*/
            //            if (rotacao > 500)// PERALTA
            //            {
            //                //                if (counter_peralta == 450)
            //                //                {
            //                //                    ig_14_temp = 10.5 - n;
            //                //                    counter_peralta = 450;
            //                //                }
            //                //                else
            //                //                {
            //                //                    ig_14_temp = 14.00 - n;
            //                //                    counter_peralta++;
            //                //                }
            //                if (counter_peralta == 450)
            //                {
            //                    ig_14_temp = 14.00 - n;
            //
            //                    counter_peralta = 450;
            //                }
            //                else
            //                {
            //
            //                    ig_14_temp = 10.5 - n;
            //                    counter_peralta++;
            //
            //                }
            //
            //            }
            /********************************************************************/

            ig_dente_14_temp = (int) ig_14_temp;

            if ((ig_dente_14_temp == 59) || (ig_dente_14_temp >= 60)) ig_dente_14_temp = 58; // Para o caso em que o sinal sobe na falha pq ele n�o consegue contar o dente 59
            else if ((ig_dente_14_temp == 29) || (ig_dente_14_temp == 30)) ig_dente_14_temp = 28; // Para o caso em que o sinal de ign 23 sobe na falha ( mesmo motivo do anterior)

            ig_tmr_disparo_temp = (ig_14_temp - (float) ig_dente_14_temp) * periodo; // forma que ele calcula para contar as casas decimais do tente
            // subtrai a vari�vel que cont�m a parte inteira da v�ri�vel q cont�m a parte decimal do dente, acha a parte decimal
            // do dente de maneira isolada, multiplica pelo per�odo para saber quanto tempo ele vai ter q contar para passar a parte decimal

            // Limite inferior para tempos de disparo da ign e inj (impede erros no Sinc)
            if (ij_tmr_disparo_temp < 10.0)
                ij_tmr_disparo_temp = 10.0;

            if (ig_tmr_disparo_temp < 10.0)
                ig_tmr_disparo_temp = 10.0;

            // CUT-OFF - Corta a injecao em caso de desaceleracoes razoaveis ou rotacoes acima de 6000 rpm
            // OBS: Abaixo de ~2000 RPM nao se corta a injecao (ajuda na estabilizacao da marcha lenta apos desaceleracao)
            if ((erro_rpm < -1000.0) || (rotacao > 6050))
            {
                ij_dente_14_temp = 200.0;
                ij_tmr_disparo_temp = 0;
                tempo_inj_temp = 0;
            }

            ig_dente_14 = ig_dente_14_temp;
            ij_dente_14 = ij_dente_14_temp;
            ig_tmr_disparo_temp = ig_tmr_disparo_temp / 52.0; //O 52 � para ajustar - OK

            if (ig_tmr_disparo_temp < 1) ig_tmr_disparo_temp = 1.0;
            if (ij_tmr_disparo_temp < 1) ij_tmr_disparo_temp = 1.0;

            ig_tmr_disparo = (int) ig_tmr_disparo_temp << 1;
            ij_tmr_disparo = (unsigned int) ij_tmr_disparo_temp;
            tempo_bob_temp = tempo_bob_temp / 52;
            tempo_bob = (int) tempo_bob_temp;
            //            if (flag == 1)
            //            {
            //                tempo_inj_temp = 4500;
            //                nPin_TESTE = ~nPin_TESTE;
            //
            //            }
            //tempo_inj_temp = tempo_inj_temp + controle_lambda;
            tempo_inj_temp = ((tempo_inj_temp * 100) / 80) * fator_corr_vbat; 
            tempo_inj = (unsigned int) tempo_inj_temp; //+ (controle_lambda * 100) / 80;

            if (!PORTB5_nL15) tempo_inj = 0;

            d = 1;
            Send_i2c = 1; // seta flag do envio da spi para na pr�xima volta calcular
            //nPin_TESTE = nPin_LOW;
        }
        b = 1;
        volta_i2c = !volta_i2c;
    } /*END Timer3*/

} /*END high interrupt*/

void interrupt low_priority Low_Isr(void)
{
//    if(TMR4IF == 1)
//    {
//        TMR4 = 0;
//        TMR4IF = 0;
//        contTimer4++;
//        if(contTimer4 > 6)
//        {
//            flagTimer4 = 1;
//            
//            contTimer4 = 0;
//        }
//    }
        
    __Interrupt_TMR1__{
        Disable_Interrupt(nINT_TIMER1);
        ClearFlag_Interrupt(nFLAG_TMR1);
        Disable_Interrupt(nINT_TIMER2);

        rotacao = 0;
        falha_ok = 0;
        t_periodo_ref = 65535; // Reseta deteccao da falha
        t_periodo = 65530;
        dente = 255;

        //        HIROKI
        //        if (!PORTB5_nL15) nRELE_BOMB_INJ = nPin_LOW; // nPin_LOW;
        //        else nRELE_BOMB_INJ = nPin_HIGH;

        //        WELLINGTON
        if (!PORTB5_nL15)
        {
            nRELE_BOMB_INJ = nPin_LOW; // nPin_LOW;
            p_rail = 0;
            cont_partida = 1000;
            estado_temp_ml = 0;
            flag_disturbio = 0;
        }
        else if (p_rail <= 100) // conta toda vez que entra na interrup��o at� aproximadamente 2s
        {
            nRELE_BOMB_INJ = nPin_HIGH; // mantem a bomba ligada durante 2s
            p_rail++;
        }
        else
        {
            nRELE_BOMB_INJ = nPin_LOW; // desliga a bomba ap�s 2s
        }


        // pedal_ad_Read();


        //ref_vb = pedal_ad - 3; // relaciona a posi�ao do pedal solto com o valor m�nimo que vc quer na borboleta
        ref_vb = 36;
        
        buffer_i2c[11] = ref_vb;
        
        
        
        
        contTimer4++;
        if(contTimer4 > 10)
        {
            contTimer4 = 0;
            flagTimer4 = 1;
        }
        
        if(flagTimer4)
        {
            t_agua_ad_Read();
            map_ad_Read();
            t_ar_ad_Read();
            Battery_ad_Read();
            lambda_Read();
                I2C_Master_Escreve_Endereco(ENDERECO_ADMISSAO, 36, ENDERECO_GERENCIAMENTO);
                
                buffer_i2c[0] = ig_dente_14;
                buffer_i2c[1] = tempo_inj >> 8;     //...
                buffer_i2c[2] = tempo_inj & 0x00FF; //16 bits
                buffer_i2c[3] = estado_controle_ml; 
                buffer_i2c[4] = ij_dente_14;
                buffer_i2c[5] = ij_tmr_disparo >> 8;     //...
                buffer_i2c[6] = ij_tmr_disparo & 0x00FF; //16 bits
                buffer_i2c[7] = tempo_bob; 
                buffer_i2c[8] = ig_tmr_disparo; 
                buffer_i2c[9] = ij_dente_14_extra; 
                buffer_i2c[10] = t_agua;
              //  buffer_i2c[10] = 24;
                

                //valores para o admiss�o
                
                
                if (ref_vb == 255)ref_vb = 254;

                buffer_i2c[11] = ref_vb;
                
                // outros valores para o comunica��o
                
                buffer_i2c[12] = rotacao >> 8;     //...
                buffer_i2c[13] = rotacao & 0x00FF; //16 bits
                
                buffer_i2c[14] = map;
                
                
                buffer_i2c[15] = angulo[0];     //...
                buffer_i2c[16] = angulo[1]; //16 bits
                
                
                buffer_i2c[17] = t_ar_com;
                buffer_i2c[18] = lambda;
                buffer_i2c[19] = VoltBattery;
                
               I2C_Master_Escreve_Multiplos_Endereco(ENDERECO_COMUNICACAO, buffer_i2c, DADOS_ENVIADOS, ENDERECO_GERENCIAMENTO);

               I2C_Leitura_Multiplos_Endereco(ENDERECO_ADMISSAO, 2, ENDERECO_GERENCIAMENTO);
                angulo[0] = buffer_read[0];
                angulo[1] = buffer_read[1];
                           
            //nLED_TEST =~nLED_TEST;
            
            flagTimer4 = 0;
           // T4CONbits.TMR4ON = 1;
        }
        
        
        
        nLED_TEST = ~nLED_TEST;
        //        nSINAL_SS_ADM = nPin_LOW;
        //        __delay_us(60);
        
        Enable_Interrupt(nINT_TIMER1);
    } /*END Timer1*/

    __Interrupt_TMR2__{
        ClearFlag_Interrupt(nFLAG_TMR2);

        if (dm == 0)
        {
            pedal_ad_Read();
            //nPin_TESTE = ~nPin_TESTE;

            if (pedal_ad <= nPEDAL_MINGOL + 2)// pedal solto
            {
                ref_torque = 0;

                if(flag_partida == 1)
                    ref_vb = 36;
                
                else if (estado_temp_ml == 0 && cont_partida < 2500 && rotacao > 5)
                {

                    switch (flag_disturbio)
                    {
                    case 0: ref_vb = 37; // 37situa��o de partida 5,0 graus
                        break;

                    case 1: ref_vb = 37; // 37 disturbio de carga acoplada ao motor borboleta em 5,5 graus
                        kp_inj = 1.4; // ganho de inje��o para corre��o da rota��o
                        break;

                    case 2: ref_vb = 35; // "mini" dash poat  para o motor n�o morrer na volta para a lenta borboleta em 4 graus
                        break;
                    }

                    estado_controle_ml = n1000_RPM; // 900 para teste
                    cont_partida++;
//                    nLED_TEST = nPin_LOW;
                }

                else if (rotacao > 5 && estado_temp_ml == 0)
                {
                    estado_temp_ml = 1;
                    flag_disturbio = 0;
                    chave_geral_control_lambda = 0;
                    kp_inj = 1.0;
                }

                if (estado_temp_ml == 1) // entra s� na primeira vez da marcha lenta para escolher o estado (tambem depois que acelera))
                {
                   
                    if (t_agua < 40)
                    {
                        estado_temp_ml = 2;
                    }
                    else if (t_agua >= 40 && t_agua < 50)
                    {
                        
                        estado_temp_ml = 3;
                    }

                    else if (t_agua > 50)
                    {
//                        nLED_TEST = nPin_HIGH;
                        estado_temp_ml = 4;
                    }
                }

                if (t_agua < 40 && estado_temp_ml == 2)
                {
                    ref_vb = 36; //34 ref vb 4,5 graus
                    estado_controle_ml = n1000_RPM; // 900 para teste
                    if (rotacao < Treshold_rpm && flag_disturbio == 1)//  850
                    {
                        estado_temp_ml = 0;
                        cont_partida = 1000;
                        flag_disturbio = 1;
                        chave_geral_control_lambda = 0;
                        //ref_vb = 37;
                        //estado_controle_ml = n1000_RPM;

                    }
                    flag_disturbio = 1;
                    //nLED_TEST = nPin_LOW;

                }

                else if ((t_agua >= 40 && t_agua < 50) && estado_temp_ml == 3)
                {
//                    nLED_TEST = nPin_LOW;
                    ref_vb = 35; //34; // ref vb � 3,5 graus
                    estado_controle_ml = n900_RPM;
                    if (rotacao < Treshold_rpm && flag_disturbio == 1)//775 800
                    {
                        estado_temp_ml = 0;
                        cont_partida = 1000;
                        flag_disturbio = 1;
                        chave_geral_control_lambda = 0;
                        //ref_vb = 37;
                        //estado_controle_ml = n1000_RPM;

                    }
                    flag_disturbio = 1;

                }

                else if ((t_agua >= 50) && estado_temp_ml == 4)
                {
                    ref_vb = refVBCal;//34; //; // 3 gaus
                    estado_controle_ml = n900_RPM;

                    if (rotacao < Treshold_rpm && flag_disturbio == 1)//775
                    {

                        estado_temp_ml = 0;
                        cont_partida = 1000;
                        flag_disturbio = 1;
                        chave_geral_control_lambda = 0;
                        //ref_vb = 37;
                        //estado_controle_ml = n1000_RPM;
                    }
                    flag_disturbio = 1;

                }


                else
                    if (estado_temp_ml > 0)
                {
                    estado_temp_ml++;
                }
            }

            else
            {

                flag_disturbio = 0;
                //estado_temp_ml = 1;
                estado_temp_ml = 0;
                cont_partida = 2000;
                ref_torque_ant = ref_torque;
                ref_torque = ((pedal_ad - 39)*100) / (nPEDAL_MAXGOL - 39); // 39 � o m�nimo valor do pedal mais 2

                if (ref_torque >= 100) ref_torque = 100;
                if (ref_torque <= 0) ref_torque = 0;



                abertura_vb = 0.01 * ref_torque * ref_torque;



                if (abertura_vb < 0)
                    abertura_vb = 0;
                else if (abertura_vb > 100.0)
                    abertura_vb = 100.0;
                //
                //
                //                                     TPS_MAX  ----------------------------
                //                                            - :                          : -
                //                                          -   :                          :   -
                //                                        -     :                          :     -
                //                                      -       :                          :       -
                //                                    -         :                          :         -
                //                                  -           :                          :           -  TPS_MAX_6000
                //                                -             :                          :            :
                //      TPS_MAX_2 ---------------               :                          :            :
                //               |              :               :                          :            :
                //               |              :               :                          :            :
                //               |              :               :                          :            :
                // TPS_MAX_1 ----               :               :                          :            :
                //               :              :               :                          :            :
                //               :              :               :                          :            :
                //              700          1700 RPM         3000 RPM                   5000 RPM     ~6000 RPM

                if (rotacao < 1400)
                {

                    abertura_vb_max = TPS_MAX_1;
                }
                else
                    if (rotacao < 2500)
                {
                    abertura_vb_max = TPS_MAX_2;
                }

                else
                    if (rotacao < rotacao_max)
                {

                    abertura_vb_max = ((TPS_MAX_3 - TPS_MAX_2)* (rotacao - rotacao_min) / (rotacao_max - rotacao_min)) + TPS_MAX_2;

                    //abertura_vb_max =  (3 * rotacao - 3500) / 100;

                    if (abertura_vb_max > 100)
                    {
                        abertura_vb_max = 100;
                    }

                }
                else
                {
                    abertura_vb_max = 100;
                }


                if (abertura_vb > abertura_vb_max)
                {
                    abertura_vb = abertura_vb_max;
                }


                //                if (rotacao <= 2000 && abertura_vb > 20)
                //                {
                //                    abertura_vb = 15;
                //                }

                ref_vb_float = abertura_vb * 2.5;


                ref_vb = ref_vb_float;
                if (ref_vb <= 36) ref_vb = 36;
                if (ref_vb >= 255) ref_vb = 255;

                //                Kref1_rpm = (6100.0 - rotacao_mlenta) / (nPEDAL_MAXGOL - nPEDAL_MINGOL);
                //                Kref2_rpm = (-(6100.0 - rotacao_mlenta)*(nPEDAL_MINGOL / (nPEDAL_MAXGOL - nPEDAL_MINGOL))) + rotacao_mlenta;

                //             if(Flag_MarchaLenta == 1 && pedal_ad <= nPEDAL_MINGOL)
                //             {
                //               ref_rpm = 1000.0;       //HIROKI
                //             }
                //             else    ref_rpm = Kref1_rpm*(float)pedal_ad + Kref2_rpm;       //HIROKI
                //                ref_rpm = (Kref1_rpm * (float) pedal_ad + Kref2_rpm) - 200; //HIROKI
                //
                //                if (ref_rpm < 1100) ref_rpm = 1100; //900; // Limite inferior da referencia

                //                else if (ref_rpm > 6500.0) ref_rpm = 6500.0; // Limite superior da referencia
                //                nPin_TESTE = ~nPin_TESTE;
                // controle_rpm();
            }

            dm = 1;
        }

        else dm = 0;
    } /*END Timer2*/
} /*END low interrupt*/
/************************************************************************************************/

/**Envia 16 Bits via SPI*/
void Spi_Write16(unsigned int data)
{

    MASTER_SPI_WRITE1(data >> 8);
    __delay_us(Time_SPI);
    MASTER_SPI_WRITE1(data & 0x00FF);
}

/*Envia 16 Bits via SPI*/
//void Spi2_Write16(unsigned int data)
//{
//
//    MASTER_SPI_WRITE2(data >> 8);
//    __delay_us(60);
//    MASTER_SPI_WRITE2(data & 0x00FF);
//}

/* Envia e le 16 bits via SPI - Usado para o MC33810 */
//long int spi_write_read_16(unsigned int data)
//{
//
//   int x, y;
//   nSINAL_SS_33810 = nPin_LOW;
//
//   __delay_us(1);
//   x = MASTER_SPI_WRITE1(data >> 8);
//   __delay_us(50);
//   y = MASTER_SPI_WRITE1(data & 0x00FF);     //M�scara para o byte mais significativo
//   __delay_us(1);
//
//   nSINAL_SS_33810 = nPin_HIGH;
//   __delay_us(50);
//   nSINAL_SS_33810 = nPin_LOW;
//
///*___________________________ Comando de leitura executado 2 vezes p/ funcionar _______________________________*/
//   __delay_us(1);
//   x = MASTER_SPI_WRITE1(data >> 8);
//   __delay_us(50);
//   y = MASTER_SPI_WRITE1(data & 0x00FF);
//   __delay_us(1);
//
//   nSINAL_SS_33810 = nPin_HIGH;
//
//   return (y >> 8)| x;
//}

/*__________________________________________ Funcao conta_dente _______________________________________________*/
inline void conta_dente()
{
    dente++; /* Contagem dos dentes */

    if (falha_ok == 0) // Inicia as medicoes e calculos somente apos detectar a falha ao menos uma vez
        return;

    if (dente == 2)
    {
        Set_Timer0(0);
    }

    if (dente == 3)
    {

        periodo = Get_Timer0(); // pega o per�odo de um dente
        Set_Timer3(65036);
        ClearFlag_Interrupt(nFLAG_TMR3);
        Enable_Interrupt(nINT_TIMER3);
    }
    a = 1;
}

void map_ad_Read()
{

    map = (Read_ADC(AN_5));
    //pressao_ar = ((map*0.493) - 3.86);
    pressao_ar = ((map * 49) - 386) / 100; //pressao_ar = ((map*49) - 386)/100;
    // pressao_ar_10bits = ((map << 2) | (ADRESL >> 6))*0.115 + 5.5; // CALCULO DA PRESS�O COM BASE NA CURVA DO POLO SOROCABA
    //pressao_ar = (0.442 * (float)map + 7.157)-20;
    //pressao_ar = 0.442 * (float)map + 7.157;   // Unidade: kPa POLO
    //pressao_ar = 0.442 * (float)map + 7.157;   //GOL
}

void lambda_Read()
{
    lambda = Read_ADC(AN_2);//Alterado diferente na placa preta do Peralta - AN3 (Marcus / well / Lucas)
    if (lambda < 112)
    {
        flag = 1;
        // nPin_TESTE = ~nPin_TESTE;
    }
    else
    {

        flag = 0;
        //nPin_TESTE = 0;
    }


}

void t_ar_ad_Read()
{

    sensor_t_ar = Read_ADC(AN_11);
    t_ar = Vet_TempAr[sensor_t_ar]; /*Valor de temperatura calculada em um vetor*/

    //rs = (float)(sensor_t_ar / (256.0 - sensor_t_ar));     //Unidade: KOhms        //Troca 255 to 256 avoid div by 0
    //t_ar = -27.25 * log(rs) + 44.52 + 273.15;              // Unidade: Kelvin POLO
    //t_ar = -44.24 * log(rs) + 63.848 + 273.15;             //GOL
    t_ar_com = (unsigned char) (t_ar - 273);
}

void t_agua_ad_Read()
{

    sensor_t_agua = Read_ADC(AN_5);
    t_agua = Vet_TempAg[sensor_t_agua]; /*Valor de Temperatura calculada em um vetor*/

    //   if(t_agua >= 78 )
    //   {
    //       Flag_MarchaLenta = 1;
    //   }
    //   else if(t_agua <= 70)
    //   {
    //      Flag_MarchaLenta = 0;
    //   }

    //rs = (float)(sensor_t_agua / (256.0 - sensor_t_agua)); // Unidade: KOhms    //Troca 255 to 256 avoid div by 0
    //t_agua = -30.57 * log(rs) + 43.01;                     // Unidade: Celsius POLO
    //t_agua = -38.38 * log(rs) + 61.69;/*GOL*/
}

void Battery_ad_Read()
{
    __delay_us(90);
    VoltBattery = Read_ADC(AN_8);
    VoltBattery = VoltBattery - 109;

    if (VoltBattery < 255)
    {
        fator_corr_vbat = VetBat[VoltBattery];

        if (fator_corr_vbat < 1.0) fator_corr_vbat = 1.0;
    }
}

void pedal_ad_Read()
{
    __delay_us(90);
    pedal_ad = Read_ADC(AN_0);
}

inline void controle_rpm()
{
    static float _control;
    static float ref_vb_temp;

    // Algoritmo de controle PI
    erro_rpm = ref_rpm - (float) rotacao;

    if ((erro_rpm < 70.0) && (erro_rpm > -70.0)) return;

    // Atualiza a somatoria
    if ((erro_rpm < 500.0) && (erro_rpm > -500.0)) soma_erro_rpm += erro_rpm; // Integracao condicional - Anti wind-up
    else soma_erro_rpm = 0; // Descarrega a somatoria

    // Anti wind-up (Limita a somatoria)
    if (soma_erro_rpm > 200000.0) soma_erro_rpm = 200000.0;
    else if (soma_erro_rpm < -200000.0) soma_erro_rpm = -200000.0;

    if (erro_rpm > 0.0)
        if (rotacao < 1700) Kp_rpm = erro_rpm * 0.08 / 5000.0; // Ajustar o primeiro parametro da formula
        else if (rotacao < 3000) Kp_rpm = erro_rpm * (0.00013 * (float) rotacao - 0.142) / 5000.0; // Ajustar o primeiro parametro da formula
        else Kp_rpm = erro_rpm * 0.25 / 5000.0; // Ajustar o primeiro parametro da formula
    else Kp_rpm = 0.0;

    _control = Kp_rpm * erro_rpm + Ki_rpm * soma_erro_rpm;
    //ref_vb_base = 0.0054 * ref_rpm + 30.07; // Posicao da vb para manter a rotacao
    ref_vb_base = 0.0054 * ref_rpm + 28; //28; // Posicao da vb para manter a rotacao
    //ref_vb_temp = 26 + _control;
    ref_vb_temp = ref_vb_base + _control; //original

    // Limitacao da posicao max da vb para o motor nao "afogar" em aceleracoes grandes
    //     if (rotacao < 1700)        ref_vb_max = 60.0;
    //     else if(rotacao < 3000)
    //     {
    //        //ref_vb_max = (nTPS_MAXPOLO - 137.0)*((float)rotacao - 1700.0)/1300.0 + 137.0;
    //        //if (ref_vb_max > nTPS_MAXPOLO)
    //        //    ref_vb_max = ;
    //
    //        ref_vb_max = (nTPS_MAXGOL - 60.0)*((float)rotacao - 1700.0)/1300.0 + 60.0;
    //        //if (ref_vb_max > nTPS_MAXGOL)       ref_vb_max = nTPS_MAXGOL;
    //     }
    //     else if(rotacao < 5000)
    //     {
    //         ref_vb_max = nTPS_MAXGOL;
    //         if (ref_vb_max > nTPS_MAXGOL)       ref_vb_max = nTPS_MAXGOL;
    //     }
    if (rotacao < 1500) ref_vb_max = 65.0; //137.0;
    else
        if (rotacao < 1800) ref_vb_max = 75.0;
    else if (rotacao < 2000) ref_vb_max = 115;
    else
    {
        //ref_vb_max = (nTPS_MAXPOLO - 137.0)*((float)rotacao - 1700.0)/1300.0 + 137.0;
        //if (ref_vb_max > nTPS_MAXPOLO)
        //    ref_vb_max = ;

        ref_vb_max = (nTPS_MAXGOL - 100.0)*((float) rotacao - 1700.0) / 1300.0 + 100; // era 170 ago 100\ original 137 era +100
        if (ref_vb_max > nTPS_MAXGOL)
        {
            ref_vb_max = nTPS_MAXGOL;

        }

        ref_vb_max_peralta = ref_vb_max + 5;
    }
    //    if (erro_rpm > 1500)
    //    {
    //        ref_vb_max = 160;
    //    }

    // Limita referencia para controle da borboleta
    /*if ((ref_vb_temp < nTPS_1000) && (rotacao > 1500))       ref_vb_temp = nTPS_1000; // PARA O MOTOR N�O CAIR MUITO R�PIDO
//    else*/ if (ref_vb_temp < MIN_REFVB) ref_vb_temp = MIN_REFVB; // Impede fechamento total da vb
    else if (ref_vb_temp > ref_vb_max)
    {
        ref_vb_temp = ref_vb_max; // Limitacao para o motor nao "afogar" em aceleracoes grandes
        // nPin_TESTE = ~nPin_TESTE;
    }
    else
    {
        // nPin_TESTE = 0;
    }
    //ref_vb = (unsigned char)ref_vb_temp; // Passa p/ a variavel final

    ATUALref_vb = (unsigned char) ref_vb_temp; // Passa p/ a variavel final
    if (ATUALref_vb > (ANTref_vb << 1) || ATUALref_vb >= 160)
    {
        ATUALref_vb = ANTref_vb;
        ref_vb = ANTref_vb + 1;
        if (ref_vb > nTPS_MAXGOL)
        {
            ref_vb = nTPS_MAXGOL - 5;
        }
    }
    else
    {
        ref_vb = (unsigned char) ref_vb_temp; // Passa p/ a variavel final
        ANTref_vb = ref_vb;
    }

    if (ref_vb >= 80)
    {
        //nLED_TEST = 0;
    }
    //else   nLED_TEST = 1;

    injecao_ok = 0; // reseta a variavel
}
//

void control_lambda()
{

    // Sinal de controle inicia com o valor anterior
    //controle_lambda = control_ant;

    // Verifica condicoes para executar o controle lambda em malha fechada:
    // * rotacao entre 500 e 5000 RPM
    // * rotacao constante (|variacao| < 150 RPM/s)
    // * ref. de torque < 70%
    // * Temperatura da agua > 50 graus Celsius (motor quente)
    // * Tempo p/ aquecimento da lambda atingido (flLambdaAquecida = 1)
    // * Tens�o da lambda menor que ~2,5V (confirma lambda aquecida)
    // * Sem erro de hardware


    //    if (lambda < 51)
    //    { // < 1V?
    //        // Mistura pobre!
    //        Rlambda = 0;
    //    }
    //    else
    //    {
    //        // Mistura rica!
    //        Rlambda = 1;
    //    }

    Rlambda = lambda * 0.01955034;
    // Calculo do erro
    erro_lambda = 1 - Rlambda;
    if (rotacao > 2500)
    {

        KIlambda = rotacao / 12850;
        KPlambda = KIlambda;
        //KIlambda = 0.1;
        //KPlambda = 0.15;

    }
    else
    {
        KIlambda = 0.07;
        KPlambda = 0.07;
    }
    //
    //    if (((control_ant <= Min_Control) && (erro_lambda < 0)) // Houve saturacao do sinal de controle?
    //            || ((control_ant >= Max_Control) && (erro_lambda > 0)))
    //        flSaturacao = 1; // Seta a flag de saturacao!

    // Calcula o incremento da parte proporcional
    U_P = KPlambda*erro_lambda;

    // Calcula o incremento da parte integral
    Ts = 120 / (float) rotacao; // Periodo do controle = 2 volta do motor

    U_I = UI_ant + KIlambda * Ts * (erro_lambda + erro_lambda_ant);

    controle_lambda = U_P + U_I;
    controle_lambda = controle_lambda * 1000;
    //controle_lbd_int = controle_lambda;
    // Limitacao da acao de controle (PWM)
    Max_Control = t_inj_real / 10;
    Min_Control = (-1) * Max_Control;
    if (controle_lambda > Max_Control)
    {
        controle_lambda = Max_Control;
    }
    else
        if (controle_lambda < Min_Control)
    {

        controle_lambda = Min_Control;
    }
    // controle_lambda = controle_lambda + controle_lambda_ant;

    erro_lambda_ant = erro_lambda;
    UI_ant = U_I;
    controle_lambda_ant = controle_lambda;
    //nPin_TESTE = ~nPin_TESTE;
}

void Delay_ms(unsigned int value)
{
    unsigned int i;
    for (i = 0; i < value; i++)
    {

        __delay_ms(1);
    }
}

void main(void)
{
    /* O sistema executar� a fun�ao main apenas uma vez*/
//    nLED_TEST = nPin_HIGH; // acende um led no hardware para ver se o programa est� chegando aqui
    Configure_HW();
    //output_high(SS); //Pino E2 para o CS do PIC comunica��o
    //LATBbits.LB1 = nPin_HIGH;
    nSINAL_SS_ADM = nPin_HIGH;
    nSINAL_SS_COM = nPin_HIGH;
    nSINAL_SS_SINC = nPin_HIGH;
    nSINAL_SS_33810 = nPin_HIGH;
    nSINAL_SS_33972 = nPin_HIGH;
    nBOMBA_CB = nPin_LOW;
//    nLED_TEST = nPin_HIGH;
    nRELE_BOMB_INJ = nPin_LOW;

    ig_dente_14 = 200; // seta um dente de referencia que n�o existe
    ij_dente_14 = 200; // seta um dente de referencia que n�o existe
    ig_tmr_disparo = 0;
    ij_tmr_disparo = 0;
    tempo_inj = 0;
    tempo_bob = 0;
    t_periodo = 65530; //Time 1ms to Timer3
    t_periodo_ref = 65535; /* Garante que o pulso de deteccao so acontecera apos
                            a comparacao do segundo pulso de sinal */
    dente = 255; // valor inv�lido de dente
    rotacao = 0;
    falha_ok = 0;
    temp = 0;
    dm = 0;
    volta_i2c = 0;

    RCONbits.IPEN = 1;
    TMR0IP = 0;
    TMR1IP = 0;
    TMR3IP = 1;
    TMR2IP = 0;
    TMR4IP = 0;


    /*------------------------Inicio Config. SPI - MC33810---------------------*/
    //                         (Driver de inje��o)
    //Selecao do SPI - MC33810
    nSINAL_SS_SINC = nPin_HIGH;
    nSINAL_SS_33810 = nPin_LOW;

    // Calibracao do Clock - MC33810
    Spi_Write16(0b1110000000000000);
    nSINAL_SS_33810 = nPin_HIGH;
    __delay_us(20);
    nSINAL_SS_33810 = nPin_LOW; // Pulso de 32us no CS do SPI
    __delay_us(32); // Requisito de calibracao do MC33810
    nSINAL_SS_33810 = nPin_HIGH;
    __delay_us(20);
    nSINAL_SS_33810 = nPin_LOW; // Mantem o SPI do MC33810 ativo

    // SPI Check - MC33810
    // OBS: O programa espera a resposta do MC33810 para prosseguir

    /* while (temp != 0b0000110100001010)
     {
          nLED_TEST = !nLED_TEST;
          temp = spi_write_read_16(0b0000111100000000);
          __delay_us(2);
     }*/

    nSINAL_SS_33810 = nPin_HIGH;
    __delay_us(20);
    nSINAL_SS_33810 = nPin_LOW;

    // Modo de Operacao - MC33810
    Spi_Write16(0b0001111100000000); // Setado p/ GENERAL PURPOSE GATE DRIVER MODE

    nSINAL_SS_33810 = nPin_HIGH;
    __delay_us(20);
    nSINAL_SS_33810 = nPin_LOW;

    // LSD Fault Command - MC33810
    Spi_Write16(0b0010101011111111);

    nSINAL_SS_33810 = nPin_HIGH;
    // Habilita saidas - MC33810
    //output_low(OUTEN_33810); //Habilitado pelo PIC Sincronismo
    //------------------------Fim Config. SPI - MC33810------------------------
    SPI_MASTER1();

    Enable_Interrupt(nINTERRUPT_GLOBAL); // Habilita chave de interrup��o global
    Enable_Interrupt(nINTERRUPT_PERIPHERAL); // habilita a chave geral de interrup��o dos perif�ricos
    Enable_Interrupt(nINT_TIMER1); // Habilita chave individual  de interrup��o do timer1 POR OVERFLOW
    Enable_ExtInt(nExt_Int0); //  Habilita chave individual de interrup��o externa
    
    I2C_Master_Init();
    nLED_TEST = 1;
    LATAbits.LA4 = 0;
    
    __delay_ms(5000);
    while(1)
    {
        
    }
    while(1);

}
/*************************************
 *       END SW GERENCIAMENTO        *
 ************************************/

/*
 *                                 PIC18F46K22
 *                          +---------:_:---------+
 *              VPP MCLR -> : 01 VPP       PGD 40 : <> RB7 PGD
 *           Battery RA0 <> : 02           PGC 39 : <> RB6 PGC
 *           Pedal1  RA1 <> : 03           PGM 38 : <> RB5 Sensor Press�o A/C
 *           Pedal2  RA2 <> : 04               37 : <> RB4 Temp Ar
 *                   RA3 <> : 05               36 : <> RB3
 *                   RA4 <> : 06 T0CKI         35 : <> RB2
 *        Temp Agua  RA5 <> : 07               34 : <> RB1
 *              MAP  RE0 <> : 08          INT0 33 : <> RB0 Rota��o
 *                   RE1 <> : 09               32 : <----- VDD
 *                   RE2 <> : 10               31 : <----- VSS
 *              VDD ------> : 11               30 : <> RD7
 *              VSS ------> : 12               29 : <> RD6 Bot�o A/C
 *    10MHZ_CRYSTAL OSC1 -> : 13 OSC1          28 : <> RD5 Freio2
 *    10MHZ_CRYSTAL OSC2 <- : 14 OSC2          27 : <> RD4
 *                   RC0 <> : 15 T1CKI         26 : <> RC7 Embreagem
 *                   RC1 <> : 16               25 : <> RC6
 *                   RC2 <> : 17               24 : <> RC5
 *                   RC3 <> : 18               23 : <> RC4
 *                   RD0 <> : 19               22 : <> RD3 Sensor de Combust�vel
 *                   RD1 <> : 20               21 : <> RD2 Freio1
 *                          +---------------------+
 *                                  DIP-40
 */
